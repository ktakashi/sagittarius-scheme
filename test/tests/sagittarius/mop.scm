(import (rnrs)
	(clos user)
	(clos core)
	(sagittarius mop allocation)
	(sagittarius mop validator)
	(srfi :64 testing))

(test-begin "Sagittarius MOP")
;; simple test not completed

(define-class <allocation-test> (<allocation-mixin>)
  ((foo :allocation :class :init-value 0)))
(let ((t (make <allocation-test>))
      (t2 (make <allocation-test>)))
  (test-equal "initial value" 0 (slot-ref t 'foo))
  (test-assert "set" (slot-set! t 'foo 5))
  (test-equal "value t"  5 (slot-ref t 'foo))
  (test-equal "value t2" 5 (slot-ref t2 'foo)))

(define-class <allocation-test2> (<allocation-mixin>)
  ((foo :allocation :instance :init-value 0)))
(let ((t (make <allocation-test2>))
      (t2 (make <allocation-test2>)))
  (test-equal "initial value" 0 (slot-ref t 'foo))
  (test-assert "set" (slot-set! t 'foo 5))
  (test-equal "value t"  5 (slot-ref t 'foo))
  (test-equal "value t2" 0 (slot-ref t2 'foo)))

(define-class <allocation-test3> ()
  ((foo :allocation :class :init-value 0))
  :metaclass <allocation-meta>)
(let ((t (make <allocation-test3>))
      (t2 (make <allocation-test3>)))
  (test-equal "initial value" 0 (slot-ref t 'foo))
  (test-assert "set" (slot-set! t 'foo 5))
  (test-equal "value t"  5 (slot-ref t 'foo))
  (test-equal "value t2" 5 (slot-ref t2 'foo)))

;; some other test
(define-class <test-meta> (<class>) ())
(define-method compute-getter-and-setter ((class <test-meta>) slot)
  (let ((r (call-next-method)))
    `(,(car r) ,(cadr r) ,(lambda (o) #f))))

(define-class <test> ()
  ((test :init-keyword :test))
  :metaclass <test-meta>)

(let ((t1 (make <test>))
      (t2 (make <test> :test #t)))
  (test-assert "slot-bound? (t1)" (not (slot-bound? t1 'test)))
  (test-assert "slot-bound? (t2)" (not (slot-bound? t2 'test)))
  (test-error "slot-ref (t1)" condition? (slot-ref t1 'test))
  (test-assert "slot-ref (t2)" (slot-ref t2 'test)))

;; validator test
(define-class <test-validate> (<validator-mixin>)
  ((number-only :validator (lambda (o v) (unless (number? v) (error 'ok)) v))
   (observ      :observer  (lambda (o v) (unless (symbol? v) (error 'ok))))))
(let ((tv (make <test-validate>)))
  (test-assert "ok number" (slot-set! tv 'number-only 1))
  (test-equal "check (1)" 1 (slot-ref tv 'number-only))
  (test-error "ng number" condition? (slot-set! tv 'number-only #t))
  (test-equal "check (2)" 1 (slot-ref tv 'number-only))
  (test-assert "ok symbol" (slot-set! tv 'observ 'ok))
  (test-equal "check (3)" 'ok (slot-ref tv 'observ))
  (test-error "ng symbol" condition? (slot-set! tv 'observ #t))
  (test-equal "check (4)" #t (slot-ref tv 'observ)))

(let ()
  (define-class <foo> (<allocation-mixin>)
    ((bar :init-keyword :bar)
     (baz :allocation :delegate :forwarding 'bar)))

  (let ((foo (make <foo> :bar 'bar)))
    (test-assert (slot-set! foo 'baz 'ok))
    (test-equal 'ok (slot-ref foo 'baz))))

(test-end)
