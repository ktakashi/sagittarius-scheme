;; extlib.stub                                -*- mode:scheme; coding:utf-8; -*-
;;
;;  Copyright (c) 2010-2016  Takashi Kato <ktakashi@ymail.com>
;;
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions
;;  are met:
;;
;;  1. Redistributions of source code must retain the above copyright
;;     notice, this list of conditions and the following disclaimer.
;;
;;  2. Redistributions in binary form must reproduce the above copyright
;;     notice, this list of conditions and the following disclaimer in the
;;     documentation and/or other materials provided with the distribution.
;;
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;
;; $Id: $
;;
(library (sagittarius)
    (export :only-bindings)
    (import (core))

  (decl-code
   (.define "LIBSAGITTARIUS_BODY")
   (.include <sagittarius.h>
	     <sagittarius/cache.h>
	     "shortnames.incl"))

  (decl-code
   (.typedef "unsigned long" "ulong"))

  (define-type <read-context> "SgReadContext*" "read-context")

  (define-cise-stmt assertion-violation
    ((_ who msg)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) '())))
    ((_ who msg irritants)
     `(begin
	(Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) ,irritants)
	 )))

  (define-cise-stmt wrong-type-of-argument-violation
    ((_ who msg got)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got '())))
    ((_ who msg got irritants)
     `(begin
	(Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg) ,got ,irritants))))


  ;; for library dependency
  (define-c-proc id-name (id::<identifier>) :constant SG_IDENTIFIER_NAME)

  (define-c-proc identifier->symbol (id) :no-side-effect
    (unless (or (SG_SYMBOLP id) (SG_IDENTIFIERP id))
      (wrong-type-of-argument-violation 'identifier->symbol
					"symbol or identifier" id))
    (if (SG_SYMBOLP id)
	(result id)
	(result (SG_IDENTIFIER_NAME id))))

  (define-c-proc id-memq (id lst) :constant
    (if (SG_IDENTIFIERP id)
	(result (Sg_Memq (SG_IDENTIFIER_NAME id) lst))
	(result (Sg_Memq id lst))))

  ;; closure?
  (define-c-proc closure? (cl) ::<boolean> :constant SG_CLOSUREP)
  (define-c-proc subr? (p) ::<boolean> :constant SG_SUBRP)

  ;; list
  (define-c-proc dotted-list? (lst) ::<boolean> :constant SG_DOTTED_LISTP)
  (define-c-proc circular-list? (lst) ::<boolean> :constant SG_CIRCULAR_LISTP)

  (define-c-proc reverse! (lis)
    (when (Sg_ConstantLiteralP lis)
      (assertion-violation 'reverse!
			   "attempt to modify constant literal"
			   lis))
    (result (Sg_ReverseX lis)))

  (define-c-proc acons (a b alist) :no-side-effect Sg_Acons)

  (define-c-proc append! (:rest lst)
    (let ((h '()) (t '()))
      (dopairs (cp lst)
	(when (and (not (SG_PAIRP (SG_CAR cp)))
		   (SG_NULLP (SG_CDR cp)))
	  (cond ((SG_NULLP h)
		 (set! h (SG_CAR cp)))
		(else
		 (SG_SET_CDR t (SG_CAR cp))))
	  (break))
	(when (and (SG_NULLP h) (Sg_ConstantLiteralP (SG_CAR cp)))
	  (assertion-violation 'append!
			       "attempt to modify constant literal"
			       (SG_CAR cp)))
	(SG_APPEND h t (SG_CAR cp)))
      (result h)))

  (define-c-proc list-copy (lst) Sg_CopyList)
 
  ;; vector
  (define-c-proc vector-copy (vec::<vector> :optional (start::<fixnum> 0)
					            (end::<fixnum> -1)
						    fill) :no-side-effect
    Sg_VectorCopy)

  (define-c-proc vector-concatenate (vec-list::<list>) :no-side-effect
    Sg_VectorConcatenate)
  (define-c-proc vector-append (:rest vec-list) :no-side-effect
    Sg_VectorConcatenate)
  
  (define-c-proc vector-reverse!
    (vec::<vector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    (when (Sg_ConstantLiteralP vec)
      (assertion-violation 'vector-reverse!
			   "attempt to modify constant literal" vec))
    (result (Sg_VectorReverseX vec start end)))

  (define-c-proc vector-reverse
    (vec::<vector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    (result (Sg_VectorReverseX (Sg_VectorCopy vec 0 -1 SG_UNBOUND) start end)))

  (define-c-proc current-exception-handlers (:optional handler)
    ;; Don't raise an error here, in case of this type of this
    ;;   (current-exception-handler (list (lambda (e) #t)))
    ;; above case is actually not recommended but it's allowed
    ;; (more precicely, there's no way to prohibit). if we raise
    ;; an error here, then it'd go into infinite loop.
    (if (SG_UNBOUNDP handler)
	(result (-> (Sg_VM) exceptionHandlers))
	(begin
	  (set! (-> (Sg_VM) exceptionHandlers) handler)
	  (result SG_UNDEF))))
  ;; misc
  (define-c-proc variable? (o) ::<boolean> :constant
    (result (or (SG_SYMBOLP o) (SG_IDENTIFIERP o))))
  ;; inexact computation
  (define-cise-stmt check-number
    ((_ name v)
     `(unless (SG_NUMBERP ,v)
	(wrong-type-of-argument-violation ',name "number" ,v))))

  ;; if we add IADD or something, these might have meaning to exists.
  (define-c-proc +. (:rest rest) :constant
    (let ((a (Sg_MakeFlonum 0.0)))
      (dolist (x rest)
	(check-number +. x)
	(set! a (Sg_Add a (Sg_Inexact x))))
      (result a)))

  (define-c-proc *. (:rest rest) :constant
    (let ((a (Sg_MakeFlonum 1.0)))
      (dolist (x rest)
	(check-number *. x)
	(set! a (Sg_Mul a (Sg_Inexact x))))
      (result a)))

  (define-c-proc -. (arg1::<number> :rest rest) :constant
    (if (SG_NULLP rest)
	(result (Sg_Negate (Sg_Inexact arg1)))
	(let ((a arg1))
	  (dolist (x rest)
	    (check-number -. x)
	    (set! a (Sg_Sub a (Sg_Inexact x))))
	  (result a))))

  (define-c-proc /. (arg1::<number> :rest rest) :constant
    (if (SG_NULLP rest)
	(result (Sg_Inverse (Sg_Inexact arg1)))
	(let ((a arg1))
	  (dolist (x rest)
	    (check-number / x)
	    (set! a (Sg_Div a (Sg_Inexact x))))
	  (result a))))

  ;; for performance
  (define-c-proc mod-inverse (x::<integer> y::<integer>) :constant
    Sg_ModInverse)
  (define-c-proc mod-expt (x::<integer> y::<integer> z::<integer>) :constant
    Sg_ModExpt)
  (define-c-proc square (x) :constant Sg_Square)

  ;; arity returns pair of required and optional arguments count.
  ;; returned pair is structured like this : (<required> . <optional>)
  ;; <required> : # of required arguments
  ;; <optional> : #t or #f
  (define-c-proc arity (p::<procedure>)
    (let ((req::int (SG_PROCEDURE_REQUIRED p))
	  (opt::int (SG_PROCEDURE_OPTIONAL p)))
      (if (> opt 0)
	  (result (Sg_Cons (SG_MAKE_INT req) #t))
	  (result (Sg_Cons (SG_MAKE_INT req) #f)))))

  (define-c-proc unbound () :constant (result SG_UNBOUND))
  (define-c-proc unbound? (o) ::<boolean> :constant SG_UNBOUNDP)
  (define-c-proc undefined () :constant (result SG_UNDEF))
  (define-c-proc undefined? (o) ::<boolean> :constant SG_UNDEFP)

  (define-c-proc add-load-path 
    (path::<string> :key (append::<boolean> #f))
    (result (Sg_AddLoadPath path append)))
  ;; very dangerous operation...
  (define-c-proc load-path (:optional paths)
    (if (SG_UNBOUNDP paths)
	(result (-> (Sg_VM) loadPath))
	(begin
	  (unless (SG_PAIRP paths) 
	    (wrong-type-of-argument-violation 'load-path "list" paths))
	  (for-each (lambda (path)
		      (unless (SG_STRINGP path) 
			(wrong-type-of-argument-violation 
			 'load-path "list of string" paths)))
		    paths)
	  (set! (-> (Sg_VM) loadPath) paths)
	  (result SG_UNDEF))))

  (define-c-proc add-load-suffix (suffix::<string>
				  :key (append::<boolean> #f)
				       (directive::<symbol> #f))
    (when (SG_FALSEP directive) (set! directive 'compatible))
    (result (Sg_AddLoadSuffix (Sg_Cons suffix directive) append)))

  ;; simpler parameter. will be used in (core macro) and compiler.
  (define (make-core-parameter init-value)
    (define (p . v)
      (if (null? v)
	  (hashtable-ref  (current-dynamic-environment) p init-value)
	  (hashtable-set! (current-dynamic-environment) p (car v))))
    p)
  (define *current-loading-port* (make-core-parameter #f))
  (define (current-load-path) 
    (cond ((*current-loading-port*) => port-filename)
	  (else #f)))
  (define (current-loading-port)
    (or (*current-loading-port*) (current-input-port)))
  (define *current-load-transcoder* (make-core-parameter
				     (make-transcoder (utf-8-codec)
						      (native-eol-style)
						      'raise)))
  (define-c-proc vm-log-level (level::<symbol>) ::<boolean> :no-side-effect
    (let ((f::int -1))
      (cond ((SG_EQ level 'info)  (set! f SG_INFO_LEVEL))
	    ((SG_EQ level 'debug) (set! f SG_DEBUG_LEVEL))
	    ((SG_EQ level 'trace) (set! f SG_TRACE_LEVEL))
	    ((SG_EQ level 'warn)  (set! f SG_WARN_LEVEL))
	    ((SG_EQ level 'fatal) (set! f SG_FATAL_LEVEL))
	    (else (return SG_FALSE)))
      (result (SG_VM_LOG_LEVEL (Sg_VM) f))))
  (define-c-proc vm-log-port () :no-side-effect (result (-> (Sg_VM) logPort)))
  (define-c-proc vm-load-flags (:optional f)
    (cond ((SG_UNBOUNDP f) (result (SG_MAKE_INT (-> (Sg_VM) flags))))
	  ((SG_INTP f)     (set! (-> (Sg_VM) flags) (SG_INT_VALUE f)))
	  ((SG_FALSEP f)
	   ;; Reset only during importing otherwise main script would
	   ;; also get affected.
	   (when (== (-> (Sg_VM) state) IMPORTING)
	     (set! (-> (Sg_VM) flags)
		   (logand (-> (Sg_VM) flags)
			   (logior SG_LOG_LEVEL_MASK
				   SG_CACHE_MASK)))))))
  (define-c-proc find-file-on-paths
    (path::<string> paths :optional (suffix::<string> #f) (raise::<boolean> #f))
    (result (Sg_FindFile path paths (?: (SG_FALSEP #f) NULL suffix)
			 (not raise))))
  
  (define (load path)
    (define (ensure-path path)
      (if (file-exists? path)
	  path
	  (find-file-on-paths path (load-path) #f #t)))
      
    (let* ((real-path (ensure-path path))
	   (in (open-file-input-port real-path #f
				     'block (*current-load-transcoder*))))
      (load-from-port in)))
  ;; for performance
  (define-c-proc make-read-context-for-load () Sg_MakeReadContextForLoad)
  (define-c-proc usec-time-usage ()
    (let ((r::uint64_t) (u::uint64_t) (s::uint64_t))
      (if (Sg_TimeUsage (& r) (& u) (& s))
	  (result (Sg_Values3 (SG_MAKE_INT 0) (SG_MAKE_INT 0) (SG_MAKE_INT 0)))
	  (result (Sg_Values3 (Sg_MakeIntegerFromU64 r)
			      (Sg_MakeIntegerFromU64 u)
			      (Sg_MakeIntegerFromU64 s))))))
  (define (load-from-port port)
    (let ((saved-port (current-loading-port))
	  (saved-flag (vm-load-flags))
	  (rc (make-read-context-for-load)))
      (define (restore)
	(*current-loading-port* saved-port)
	(vm-load-flags saved-flag)
	;; should we?
	(close-port port))
      (define (main-loop)
	(let loop ()
	  (let* ((reader (port-reader port))
		 (expr (if reader
			   (reader port)
			   (read-with-context port rc))))
	    (if (eof-object? expr)
		#t
		(begin
		  (eval expr #f)
		  (loop))))))
      (*current-loading-port* port)
      (vm-load-flags #f)
      (if (vm-log-level 'info)
	  (let-values (((sr su ss) (usec-time-usage)))
	    (dynamic-wind values
		main-loop
		(lambda ()
		  (let-values (((er eu es) (usec-time-usage)))
		    (format (vm-log-port) ";; loaded ~s [~a ms]~%"
			    (or (current-load-path) port)
			    (round (div (- er sr) 1000))))
		  (restore))))
	  (dynamic-wind values main-loop restore))))
      
  (define-c-proc gensym (:optional prefix::<string>) :no-side-effect
    (when (SG_UNBOUNDP prefix) (set! prefix NULL))
    (result (Sg_Gensym prefix)))

  (define-c-proc unwrap-syntax (form) :no-side-effect Sg_UnwrapSyntax)

  (define-c-proc current-dynamic-environment
    (:optional other::<weak-hashtable>)
    (if (SG_UNBOUNDP other)
	(result (-> (Sg_VM) parameters))
	(begin
	  (set! (-> (Sg_VM) parameters) other)
	  (result SG_UNDEF))))
    
  (define-c-proc add-dynamic-load-path
    (path::<string> :key (append::<boolean> #f))
    (result (Sg_AddDynamicLoadPath path append)))

  (define-c-proc load-dynamic-library (name::<string> :optional init)
    (result (Sg_DynLoad name init 0)))

  ;; this will never be constant :)
  (define-c-proc sagittarius-version () :no-side-effect
    (result (SG_MAKE_STRING SAGITTARIUS_VERSION)))

  (define-c-proc report-error (e :optional (out (Sg_CurrentErrorPort))) ::<void>
    Sg_ReportError)

  (define-c-proc describe-condition (e) Sg_DescribeCondition)

  ;; symbol
  (define-c-proc interned-symbol? (s) ::<boolean> :no-side-effect
    SG_INTERNED_SYMBOL)

  (define-cise-stmt check-symbol
    ((_ name s)
     `(unless (SG_SYMBOLP ,s)
	(wrong-type-of-argument-violation ',name "symbol" ,s))))

  (define-cise-stmt symbol-compare
    ((_ compare value name first second rest)
     `(begin
	(cond ((SG_NULLP ,rest)
	       (result (,compare (Sg_StringCompare (SG_SYMBOL_NAME ,first)
						   (SG_SYMBOL_NAME ,second))
				 ,value)))
	      ((not (,compare (Sg_StringCompare (SG_SYMBOL_NAME ,first)
						(SG_SYMBOL_NAME ,second)) 
			      ,value))
	       (result FALSE))
	      (else
	       (let ((prev ,second))
		 (dolist (p ,rest)
		   (check-symbol ,name p)
		   (unless (,compare (Sg_StringCompare (SG_SYMBOL_NAME prev)
						       (SG_SYMBOL_NAME p))
				     ,value)
		     (return #f))
		   (set! prev p))
		 (result TRUE)))))))

  (define-c-proc symbol<? (s1::<symbol> s2::<symbol> :rest rest)
    ::<boolean> :constant
    (symbol-compare == -1 symbol<? s1 s2 rest))
  (define-c-proc symbol>? (s1::<symbol> s2::<symbol> :rest rest)
    ::<boolean> :constant
    (symbol-compare == 1 symbol>? s1 s2 rest))
  (define-c-proc symbol<=? (s1::<symbol> s2::<symbol> :rest rest)
    ::<boolean> :constant
    (symbol-compare <= 0 symbol<=? s1 s2 rest))
  (define-c-proc symbol>=? (s1::<symbol> s2::<symbol> :rest rest)
    ::<boolean> :constant
    (symbol-compare >= 0 symbol>=? s1 s2 rest))

  ;; SRFI-17
  (define-c-proc setter (proc) :no-side-effect
    (setter (proc::<procedure> setter::<procedure>) ::<void>
	    (Sg_SetterSet proc setter FALSE))
    Sg_Setter)

  (define-c-proc has-setter? (proc) ::<boolean> :no-side-effect Sg_HasSetter)

  ;; filesystem
  (define-cise-stmt raise-i/o-error
    ((_ who filename)
     (let ((r (gensym)))
       `(let ((,(string->symbol (format "~a::int" r)) (Sg_GetLastError)))
	  (raise-i/o-error ,who ,r ,filename))))
    ((_ who e filename)
     `(Sg_IOError (Sg_ErrnoToIOErrorType ,e)
		  ',who
		  (Sg_GetLastErrorMessageWithErrorCode ,e)
		  ,filename SG_FALSE)))
  
  (define-c-proc copy-file
    (src::<string> dst::<string> :optional (overwrite?::<boolean> #f)) 
    ::<boolean>
    (let ((r::int (Sg_CopyFile src dst overwrite?)))
      (when r (raise-i/o-error copy-file r src))
      (result TRUE)))

  (define-c-proc file-size-in-bytes (path::<string>) :no-side-effect
    (let ((size (Sg_FileSize path)))
      (when (SG_FALSEP size) (raise-i/o-error file-size-in-bytes path))
      (result size)))
  
  (define-c-proc file-regular? (path::<string>) ::<boolean> :no-side-effect
    Sg_FileRegularP)

  (define-c-proc file-directory? (path::<string>) ::<boolean> :no-side-effect
    Sg_DirectoryP)

  (define-c-proc file-symbolic-link? (path::<string>) ::<boolean> :no-side-effect
    Sg_FileSymbolicLinkP)

  (define-c-proc file-readable? (path::<string>) ::<boolean> :no-side-effect
    Sg_FileReadableP)

  (define-c-proc file-writable? (path::<string>) ::<boolean> :no-side-effect
    Sg_FileWritableP)

  (define-c-proc file-executable? (path::<string>) ::<boolean> :no-side-effect
    Sg_FileExecutableP)

  (define-c-proc file-stat-ctime (path::<string>) :no-side-effect
    (let ((tm (Sg_FileChangeTime path)))
      (when (SG_FALSEP tm) (raise-i/o-error file-stat-ctime path))
      (result tm)))

  (define-c-proc file-stat-mtime (path::<string>) :no-side-effect
    (let ((tm (Sg_FileModifyTime path)))
      (when (SG_FALSEP tm) (raise-i/o-error file-stat-mtime path))
      (result tm)))

  (define-c-proc file-stat-atime (path::<string>) :no-side-effect
    (let ((tm (Sg_FileAccessTime path)))
      (when (SG_FALSEP tm) (raise-i/o-error file-stat-atime path))
      (result tm)))

  (define-c-proc create-symbolic-link (oldpath::<string> newpath::<string>)
    ::<void>
    (let ((r::int (Sg_CreateSymbolicLink oldpath newpath)))
      (when r (raise-i/o-error create-symbolic-link r oldpath))))

  (define-c-proc rename-file (oldpath::<string> newpath::<string>) ::<void>
    (let ((r::int (Sg_FileRename oldpath newpath)))
      (when r (raise-i/o-error rename-file r oldpath))))

  (define-c-proc change-file-mode (file::<string> mode::<fixnum>) ::<void>
    (let ((r::int (Sg_ChangeFileMode file mode)))
      (when r (raise-i/o-error change-file-mode r file))))

  (define-c-proc change-file-timestamps! (file::<string> mtime atime) ::<boolean>
    Sg_Utimes)
  
  (define-c-proc delete-directory (path::<string>) ::<void>
    (let ((r::int (Sg_DeleteFileOrDirectory path)))
      (when r (raise-i/o-error delete-directory r path))))

  (define-c-proc create-directory (path::<string>) ::<void>
    (let ((r::int (Sg_CreateDirectory path)))
      (when r (raise-i/o-error create-directory r path))))

  (define-c-proc read-directory (path::<string>) :no-side-effect
    Sg_ReadDirectory)

  ;; make this parameterizable
  (define-c-proc current-directory (:optional path::<string>)
    (cond ((SG_UNBOUNDP path)
	   (result (Sg_CurrentDirectory)))
	  (else
	   (Sg_SetCurrentDirectory path)
	   (result SG_UNDEF))))

  (define-c-proc set-current-directory (path::<string>) ::<void>
    Sg_SetCurrentDirectory)

  (define-c-proc build-path (path::<string> file::<string>) :no-side-effect
    Sg_BuildPath)
  (define-c-proc absolute-path? (path::<string>) ::<boolean> :no-side-effect
    Sg_AbsolutePathP)
  (define-c-proc absolute-path (path::<string>) :no-side-effect
    Sg_AbsolutePath)

  (define-cfn retrieve-flags (list) ::int :static
    (let ((flags::int 0))
      (dolist (flag list)
	(cond ((SG_EQ flag 'dot-match) (set! flags (logior flags SG_DOTMATCH)))
	      ((SG_EQ flag 'noescape)  (set! flags (logior flags SG_NOESCAPE)))
	      ((SG_EQ flag 'case-fold) (set! flags (logior flags SG_CASEFOLD)))
	      ((SG_EQ flag 'pathname)  (set! flags (logior flags SG_PATHNAME)))
	      (else
	       (assertion-violation 'glob
				    "unknown flag symbol appeared"
				    (SG_LIST2 flag list)))))
      (return flags)))

  (define-c-proc glob (path::<string> :rest flags) :no-side-effect
    ;; for now
    (result (Sg_Glob path (retrieve-flags flags))))

  (define-c-proc find-default-directive-by-path (path) :no-side-effect
    Sg_FindDefaultDirectiveByPath)
  
  ;; should we make this constant?
  (define-c-proc directory-name (p::<string>) :no-side-effect Sg_DirectoryName)

  (define-c-proc sagittarius-installed-directory () :no-side-effect
    Sg_InstalledDirectory)

  (define-c-proc copy-access-control (src::<string> dst::<string>) ::<boolean>
    Sg_CopyAccessControl)

  (define-cise-stmt check-port-open
    ((_ name p)
     `(when (Sg_PortClosedP ,p)
	(wrong-type-of-argument-violation ',name "opened port" ,p))))

  (define-c-proc lock-port-resource!
    (port::<port> :key (lock-type::<symbol> shared) (wait::<boolean> #t)
		  (raise::<boolean> #t))
    (check-port-open lock-port! port)
    (let ((flags::int 0))
      (cond ((SG_EQ lock-type 'shared)    (set! flags SG_SHARED))
	    ((SG_EQ lock-type 'exclusive) (set! flags SG_EXCLUSIVE))
	    (else
	     (assertion-violation 'lock-port!
				  "unsupported lock-type" lock-type)))
      (unless wait (set! flags (logior flags SG_DONT_WAIT)))
      (result SG_FALSE)
      (if (Sg_LockPortResource port flags)
	  (result port)
	  (when raise
	    (Sg_IOError -1 'lock-port! (Sg_GetLastErrorMessage)
			NULL port)))))

  (define-c-proc unlock-port-resource! (port::<port>)
    ;; should we raise an error if failed?
    (Sg_UnlockPortResouce port)
    (result port))

  (define-c-proc get-bytevector-until (port::<port> bv::<bytevector>)
    Sg_ReadbUntil)

  ;; readonly current library access
  ;; it's nice to have this
  (define-c-proc current-library () :no-side-effect
    (result (-> (Sg_VM) currentLibrary)))

  ;; string
  (define-c-proc string-scan (s1::<string> s2 :optional (mode 'index))
    :no-side-effect
    (let ((rmode::int 0))
      (cond ((SG_EQ mode 'index)   (set! rmode SG_STRING_SCAN_INDEX))
	    ((SG_EQ mode 'before)  (set! rmode SG_STRING_SCAN_BEFORE))
	    ((SG_EQ mode 'after)   (set! rmode SG_STRING_SCAN_AFTER))
	    ((SG_EQ mode 'before*) (set! rmode SG_STRING_SCAN_BEFORE2))
	    ((SG_EQ mode 'after*)  (set! rmode SG_STRING_SCAN_AFTER2))
	    ((SG_EQ mode 'both)    (set! rmode SG_STRING_SCAN_BOTH))
	    (else
	     (assertion-violation 'string-scan
				  "bad value in mode argument. it must be one of 'index, 'before, 'after, 'before*, 'after* or 'both"
				  mode)))
      (cond ((SG_STRINGP s2) (result (Sg_StringScan s1 (SG_STRING s2) rmode)))
	    ((SG_CHARP s2)   (result (Sg_StringScanChar s1 (SG_CHAR_VALUE s2) rmode)))
	    (else
	     (wrong-type-of-argument-violation 'string-scan
					       "string or char"
					       s2
					       (SG_LIST3 s1 s2 mode))))))
  (define-c-proc string-concatenate (strings::<list>) :no-side-effect
    Sg_StringAppend)

  (define-c-proc %maybe-substring 
    (s::<string> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    Sg_MaybeSubstring)

  ;; for SRFI-129
  (define-c-proc string-titlecase/special-casing
    (s::<string> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    (result (Sg_StringTitleCase (Sg_MaybeSubstring s start end) TRUE)))

  (define-c-proc literal-string? (s::<string>) ::<boolean> :constant Sg_LiteralStringP)
  ;; for SRFI-135 and SRFI-140
  (define-c-proc string->istring
    (s::<string> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    Sg_StringToIString)
  (define-c-proc istring? (s) ::<boolean> :constant SG_IMMUTABLE_STRINGP)
  

  ;; hashtable
  ;; FIXME this is also in null.stub but we don't want to make it extern...
  (define-cfn retrieve-weakness (weakness) ::SgWeakness :static
    (cond ((SG_EQ weakness 'key)   (return SG_WEAK_KEY))
	  ((SG_EQ weakness 'value) (return SG_WEAK_VALUE))
	  ((SG_EQ weakness 'both)  (return SG_WEAK_BOTH))
	  ;; NB: we don't support ephemerals
	  (else (assertion-violation 'make-hashtable
		  "weakness must be one of 'key, 'value or 'both" weakness)
		;; dummy
		(return -1))))
  (define-c-proc make-equal-hashtable (:optional (k? #f) (weakness #f))
    :no-side-effect
    (let ((k::long -1))
      (cond ((SG_INTP k?) (set! k (SG_INT_VALUE k?)))
	    ((SG_FALSEP k?) (set! k 200))
	    (else 
	     (wrong-type-of-argument-violation 'make-equal-hashtable
					       "#f or fixnum" k?)))
      (when (< k 0) 
	(wrong-type-of-argument-violation 'make-equal-hashtable 
					  "non negative exact integer"
					  (SG_MAKE_INT k)))
      (if (SG_FALSEP weakness)
	  (result (Sg_MakeHashTableSimple SG_HASH_EQUAL k))
	  (let ((w::SgWeakness (retrieve-weakness weakness)))
	    (result (Sg_MakeWeakHashTableSimple SG_HASH_EQUAL w k SG_UNDEF))))))

  (define-c-proc make-string-hashtable (:optional (k? #f) (weakness #f))
    :no-side-effect
    (let ((k::long -1))
      (cond ((SG_INTP k?) (set! k (SG_INT_VALUE k?)))
	    ((SG_FALSEP k?) (set! k 200))
	    (else 
	     (wrong-type-of-argument-violation 'make-string-hashtable
					       "#f or fixnum" k?)))
      (when (< k 0) 
	(wrong-type-of-argument-violation 'make-string-hashtable 
					  "non negative exact integer"
					  (SG_MAKE_INT k)))
      (if (SG_FALSEP weakness)
	  (result (Sg_MakeHashTableSimple SG_HASH_STRING k))
	  (let ((w::SgWeakness (retrieve-weakness weakness)))
	    (result (Sg_MakeWeakHashTableSimple SG_HASH_STRING w k 
						SG_UNDEF))))))

  (define-c-proc hashtable-keys-list (ht::<hashtable>) :no-side-effect
    Sg_HashTableKeys)

  (define-c-proc hashtable-values-list (ht::<hashtable>) :no-side-effect
    Sg_HashTableValues)

  (define-c-proc hashtable-type (ht::<hashtable>) :no-side-effect
    (cond ((== (-> ht type) SG_HASH_EQ)
	   (result 'eq))
	  ((== (-> ht type) SG_HASH_EQV)
	   (result 'eqv))
	  ((== (-> ht type) SG_HASH_EQUAL)
	   (result 'equal))
	  ((== (-> ht type) SG_HASH_STRING)
	   (result 'string))
	  ((== (-> ht type) SG_HASH_GENERAL)
	   (result 'general))
	  (else
	   (assertion-violation 'hashtable-type
				"invalid hashtable type"
				ht))))

  (define-c-proc hashtable-compare (ht::<hashtable>) :no-side-effect
    (result (-> (SG_HASHTABLE_CORE ht) generalCompare)))

  (define-c-proc hashtable-hasher (ht::<hashtable>) :no-side-effect
    (result (-> (SG_HASHTABLE_CORE ht) generalHasher)))

  ;; just for consistancy
  (define-c-proc hashtable-values (ht::<hashtable>) :no-side-effect
    (let ((itr::SgHashIter)
	  (r (Sg_MakeVector (-> (SG_HASHTABLE_CORE ht) entryCount) SG_UNDEF))
	  (v)
	  (i::int 0))
      (Sg_HashIterInit ht (& itr))
      (while (!= (Sg_HashIterNext (& itr) NULL (& v)) NULL)
	(set! (SG_VECTOR_ELEMENT r (post++ i)) v))
      (result r)))

  (define-c-proc hashtable-weakness (ht::<hashtable>) :no-side-effect
    (if (SG_WEAK_HASHTABLE_P ht)
	(let* ((w::SgWeakness (-> (SG_WEAK_HASHTABLE ht) weakness))
	       (k::int (logand w SG_WEAK_KEY))
	       (v::int (logand w SG_WEAK_VALUE)))
	  (cond ((and k v) (result 'both))
		(k (result 'key))
		(v (result 'value))))
	(result #f)))

  (define-cise-stmt dict-update!
    ((_ dict searcher xtractor cc set unwrap)
     `(let ((e::SgDictEntry*)
	    (data::(.array void* (2))))
	(set! e (,searcher (,xtractor ,dict) (cast intptr_t key)
			   SG_DICT_CREATE 0))
	(unless (-> e value) (cast void (,set ,dict e default)))
	(set! (aref data 0) (cast void* e))
	(set! (aref data 1) (cast void* ,dict))
	(Sg_VMPushCC ,cc data 2)
	(result (Sg_VMApply1 proc (,unwrap ,dict e))))))
  
  ;; update!
  (define-cfn hashtable-update-cc (result data::void**) :static
    (let ((e::SgDictEntry* (cast SgDictEntry* (aref data 0)))
	  (ht (aref data 1)))
      (SG_HASHTABLE_ENTRY_SET ht e result 0)
      (return result)))

  (define-cise-expr hash-entry-set!
    ((_ dict e value)
     `(SG_HASHTABLE_ENTRY_SET ,dict ,e ,value 0)))
  (define-cise-expr hash-entry-value
    ((_ dict e) 
     `(SG_HASHTABLE_ENTRY_REF ,dict ,e 0)))
  (define-c-proc hashtable-update! 
    (ht::<hashtable> key proc::<procedure> default)
    (when (SG_IMMUTABLE_HASHTABLE_P ht)
      (assertion-violation 'hashtable-update!
			   "attemp to modify an immutable hashtable" ht))
    (dict-update! ht Sg_HashCoreSearch SG_HASHTABLE_CORE
		  hashtable-update-cc
		  hash-entry-set!
		  hash-entry-value))

  ;; from Gauche
  (define-cfn hashtable-itr (args::SgObject* argc::int data::void*) :static
    (let* ((itr::SgHashIter* (cast SgHashIter* data))
	   (k SG_UNDEF)
	   (v SG_UNDEF)
	   (eofval (aref args 0)))
      (if (Sg_HashIterNext itr (& k) (& v))
	  (return (Sg_Values2 k v))
	  (return (Sg_Values2 eofval eofval)))))
  (define-c-proc %hashtable-iter (ht::<hashtable>)
    (let ((itr::SgHashIter* (SG_NEW SgHashIter)))
      (Sg_HashIterInit ht itr)
      (result (Sg_MakeSubr hashtable-itr itr 1 0 
			   (SG_MAKE_STRING "hashtable-iterator")))))

  ;; the same as symbol-hash but different procedure
  ;; defined in compare.c
  ;;(define-c-proc eq-hash (o) ::<fixnum> :no-side-effect Sg_EqHash)
  ;; (define-c-proc eqv-hash (o) :no-side-effect
  ;;    (result (Sg_MakeIntegerU (Sg_EqvHash o))))

  ;; error
  (define-c-proc with-error-handler
    (handler::<procedure> thunk::<procedure>
			  :optional (rewindBefore::<boolean> #f))
    (result (Sg_VMWithErrorHandler handler thunk rewindBefore)))

  ;; io
  (define-cise-stmt check-binary-port
    ((_ name p)
     `(unless (SG_BINARY_PORTP ,p)
	(wrong-type-of-argument-violation ',name "binary-port" ,p))))
  (define-cise-stmt check-input-port
    ((_ name p)
     `(unless (SG_INPUT_PORTP ,p)
	(wrong-type-of-argument-violation ',name
					  "input port"
					  ,p))))
  (define-cise-stmt check-output-port
    ((_ name p)
     `(unless (SG_OUTPUT_PORTP ,p)
	(wrong-type-of-argument-violation ',name
					  "output port"
					  ,p))))

  (define-cise-macro (safe-oport-operation form env)
    (ensure-stmt-ctx form env)
    (let ((eenv (expr-env env))
	  (p (cadr form))
	  (call (caddr form)))
      `("\ndo {"
	"\n  SG_UNWIND_PROTECT {"
	,(render-rec call env)
	"\n  } SG_WHEN_ERROR {"
	"\n    SG_PORT_UNLOCK_WRITE(" ,(render-rec p eenv) ");"
	"\n    SG_NEXT_HANDLER;"
	"\n  } SG_END_PROTECT;"
	"\n} while (0);\n")))
  
  ;; moved from (binary io) so that we don't have to
  ;; allocate bytevectors
  ;;
  ;; NOTE:
  ;; We only defines 16 bits and 32 bits for now.
  ;; Benchmarking told me that the difference is only 200ms when
  ;; it's executed 1000000 and 11 gc. (calling get-u16 twice)
  ;; I don't see that much improvement and we aren't using this
  ;; that much. So for now, only these experimental 2 are more 
  ;; than enough.
  (define-cise-stmt put-un
    ((_ name out v size endian)
     `(begin
	(check-binary-port ,name ,out)
	(check-output-port ,name ,out)
	(SG_PORT_LOCK_WRITE ,out)
	(safe-oport-operation
	 ,out
	 (cond ((SG_EQ ,endian 'big)
		(let ((i::int ,(- size 1)))
		  (for (() (>= i 0) (post-- i))
		       (Sg_PutbUnsafe ,out (logand (ashr ,v (* i 8)) #xFF)))))
	       ((SG_EQ ,endian 'little)
		(dotimes (i ,size)
		  (Sg_PutbUnsafe ,out (logand ,v #xFF))
		 (set! ,v (ashr ,v 8))))
	       ((SG_EQ ,endian 'native)
		(Sg_WritebUnsafe ,out (cast uint8_t* (& ,v)) 0 ,size))
	       (else
		(assertion-violation ',name "unsupported endianness" 
				     ,endian))))
	(SG_PORT_UNLOCK_WRITE ,out))))

  (define-c-proc put-u16 (out::<port> v::<fixnum> endian::<symbol>) ::<void>
    (unless (and (<= 0 v) (<= v #xFFFF))
      (assertion-violation 'put-u16 "given value must be 0 <= n <= #xFFFF"
			   (SG_MAKE_INT v)))
    (put-un put-u16 out v 2 endian))
  (define-c-proc put-s16 (out::<port> v::<fixnum> endian::<symbol>) ::<void>
    (unless (and (<= #x-8000 v) (<= v #x7FFF))
      (assertion-violation 'put-s16 "given value must be #x-8000 <= n <= #x7FFF"
			   (SG_MAKE_INT v)))
    (put-un put-s16 out v 2 endian))

  (define-c-proc put-u32 (out::<port> n::<integer> endian::<symbol>) ::<void>
    (let ((oor::int 0)
	  (v::ulong (Sg_GetUIntegerClamp n SG_CLAMP_NONE (& oor))))
      (unless (and (not oor) (<= v UINT32_MAX))
	(assertion-violation 'put-u32 
			     "given value must be 0 <= n <= #xFFFFFFFF"
			     n))
      (put-un put-u32 out v 4 endian)))
  (define-c-proc put-s32 (out::<port> n::<integer> endian::<symbol>) ::<void>
    (let ((v::long (Sg_GetIntegerClamp n SG_CLAMP_NONE NULL)))
      (unless (and (<= INT32_MIN v) (<= v INT32_MAX))
	(assertion-violation 'put-s32 
	     "given value must be #x-80000000 <= n <= #x7FFFFFFF"
	     n))
      (put-un put-s32 out v 4 endian)))
  ;; TODO u64, s64, f32, f64, u* and s*

  (define-cise-macro (safe-rport-operation form env)
    (ensure-stmt-ctx form env)
    (let ((eenv (expr-env env))
	  (p (cadr form))
	  (call (caddr form)))
      `("\ndo {"
	"\n  SG_UNWIND_PROTECT {"
	,(render-rec call env)
	"\n  } SG_WHEN_ERROR {"
	"\n    SG_PORT_UNLOCK_READ(" ,(render-rec p eenv) ");"
	"\n    SG_NEXT_HANDLER;"
	"\n  } SG_END_PROTECT;"
	"\n} while (0);\n")))
  (define-cise-stmt get-un
    ((_ name in size endian type make)
     `(begin
	(check-binary-port ,name ,in)
	(check-input-port ,name ,in)
	(SG_PORT_LOCK_READ ,in)
	(let ((r :: ,type 0))
	  (safe-rport-operation
	   ,in
	   (cond ((SG_EQ ,endian 'big)
		  (dotimes (i ,size)
		    (let ((t::int (Sg_GetbUnsafe ,in)))
		      (when (== EOF t)
			(assertion-violation ',name "unexpected EOF"))
		      (set! r (logior (ashl r 8) t)))))
		 ((SG_EQ ,endian 'little)
		  (dotimes (i ,size)
		    (let ((t::int (Sg_GetbUnsafe ,in)))
		      (when (== EOF t)
			(assertion-violation ',name "unexpected EOF"))
		      (set! r (logior r (ashl t (* i 8)))))))
		 ((SG_EQ ,endian 'native)
		  (Sg_ReadbUnsafe ,in (cast uint8_t* (& r)) ,size))
		 (else
		  (assertion-violation ',name "unsupported endianness" 
				       ,endian))))
	  (SG_PORT_UNLOCK_READ ,in)
	  (result (,make r))))))
 
   (define-c-proc get-u16 (in::<port> endian::<symbol>)
     (get-un get-u16 in 2 endian uint16_t SG_MAKE_INT))
   (define-c-proc get-s16 (in::<port> endian::<symbol>)
     (get-un get-s16 in 2 endian int16_t SG_MAKE_INT))
   (define-c-proc get-u32 (in::<port> endian::<symbol>)
     (get-un get-u32 in 4 endian uint32_t Sg_MakeIntegerU))
   (define-c-proc get-s32 (in::<port> endian::<symbol>)
     (get-un get-s32 in 4 endian int32_t Sg_MakeInteger))
   ;; TODO u64, s64, f32, f64, u* and s*

  (define-c-proc port-closed? (p::<port>) ::<boolean>  :no-side-effect
    Sg_PortClosedP)

  (define-c-proc port-case-insensitive? (p::<port>) ::<boolean>  :no-side-effect
    Sg_PortCaseInsensitiveP)

  (define-c-proc write/ss (o :optional (p::<port> (Sg_CurrentOutputPort)))
    ::<void>
    (check-port-open write/ss p)
    (check-output-port write/ss p)
    (Sg_Write o p SG_WRITE_SHARED))

  (define-c-proc write-cyclic 
    (o :optional (p::<port> (Sg_CurrentOutputPort))) ::<void>
    (check-port-open write-cyclic p)
    (check-output-port write-cyclic p)
    (Sg_WriteCircular o p SG_WRITE_WRITE -1))

  (define-c-proc read-line (:optional (p::<port> (Sg_CurrentInputPort)))
    (check-port-open read-line p)
    ;; (check-textual-port read-line p)
    (check-input-port read-line p)
    (unless (SG_TEXTUAL_PORTP p)
      (wrong-type-of-argument-violation 'read-line "textual port" p))
    (result (Sg_ReadLine p E_NONE)))

  (define-c-proc read/ss (:optional (p::<port> (Sg_CurrentInputPort))
				    :key (source-info?::<boolean> #f))
    (check-port-open read/ss p)
    (check-input-port read/ss p)
    (let ((ctx::SgReadContext SG_STATIC_READ_CONTEXT))
      (when source-info?
	(set! (ref ctx flags) SG_READ_SOURCE_INFO))
      (set! (ref ctx graph)  (Sg_MakeHashTableSimple SG_HASH_EQ 1))
      (result (Sg_ReadWithContext p (& ctx)))))

  (define-cfn string-format (fmt objs) :static
    (let ((out::SgPort*)
	  (tp::SgStringPort)
	  (r))
      (set! out (Sg_InitStringOutputPort (& tp) 16))
      (Sg_Format out fmt objs FALSE)
      (set! r (Sg_GetStringFromStringPort (& tp)))
      (SG_CLEAN_STRING_PORT (& tp))
      (return r)))

  (define-c-proc format (p :rest rest)
    (cond ((SG_PORTP p)
	   (check-port-open format p)
	   (check-output-port format p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (Sg_Format p fmt objs FALSE)
	     (result SG_UNDEF)))
	  ((SG_BOOLP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (if (SG_FALSEP p)
		 (result (string-format fmt objs))
		 (let ((out (Sg_CurrentOutputPort)))
		   (Sg_Format out fmt objs FALSE)
		   (result SG_UNDEF)))))
	  ((SG_STRINGP p)
	   (result (string-format p rest)))))

  (define-c-proc format/ss (p :rest rest)
    (cond ((SG_PORTP p)
	   (check-port-open format p)
	   (check-output-port format p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (Sg_Format p fmt objs TRUE)
	     (result SG_UNDEF)))
	  ((SG_BOOLP p)
	   (let ((fmt::SgString* (SG_CAR rest))
		 (objs (SG_CDR rest)))
	     (if (SG_FALSEP p)
		 (let ((out (Sg_MakeStringOutputPort 16)))
		   (Sg_Format out fmt objs TRUE)
		   (result (Sg_GetStringFromStringPort out)))
		 (let ((out (Sg_CurrentOutputPort)))
		   (Sg_Format out fmt objs TRUE)
		   (result SG_UNDEF)))))
	  ((SG_STRINGP p)
	   (let ((out (Sg_MakeStringOutputPort 16)))
	     (Sg_Format out p rest TRUE)
	     (result (Sg_GetStringFromStringPort out))))))

  ;; let user handle buffer as well
  (define-c-proc buffered-port 
    (port::<port> buffer-mode::<symbol> :key buffer::<bytevector>)
    (unless (SG_BINARY_PORTP port)
      (wrong-type-of-argument-violation 'buffered-port "binary port" port))
    (when (Sg_PortClosedP port)
      (wrong-type-of-argument-violation 'buffered-port "opened port" port))
    ;; already buffered port
    ;; TODO should we allow this so that user can do something like
    ;;      line buffer <-> block buffe?
    (when (SG_BUFFERED_PORTP port) (return port))
    (let ((mode::int SG_BUFFER_MODE_BLOCK)
	  (buf::uint8_t* NULL)
	  (size::size_t 0))
      (cond ((SG_EQ buffer-mode 'none) (return port))
	    ((SG_EQ buffer-mode 'line) (set! mode SG_BUFFER_MODE_LINE))
	    ((SG_EQ buffer-mode 'block) (set! mode SG_BUFFER_MODE_BLOCK))
	    (else (assertion-violation 'buffered-port
				       "unknown buffer mode is given"
				       buffer-mode)))
      (when (SG_BVECTORP buffer) 
	(when (SG_LITERAL_BVECTORP buffer)
	  (assertion-violation 'buffered-port 
		       "literal bytevector can not be used as a buffer"))
	(set! buf (SG_BVECTOR_ELEMENTS buffer)
	      size (SG_BVECTOR_SIZE buffer))
	(when (== size 0)
	  (assertion-violation 'buffered-port
			       "given bytevector size is zero")))
      (Sg_PseudoClosePort port)
      (result (Sg_MakeBufferedPort port mode buf size))))

  ;; R6RS variant interface
  ;; NOTE: we don't document this until I have absolutely confident.
  (define-cise-stmt check-procedure-or-false
    ((_ name proc)
     `(unless (or (SG_FALSEP ,proc) (SG_PROCEDUREP ,proc))
	(wrong-type-of-argument-violation ',name "procedure or #f" ,proc))))
  (define-c-proc make-custom-binary-bidirectional-port
    (id::<string> read::<procedure> write::<procedure> close 
		  :optional (ready #f))
    (check-procedure-or-false make-custom-binary-bidirectional-port close)
    (check-procedure-or-false make-custom-binary-bidirectional-port ready)
    (result (Sg_MakeCustomBinaryPort id SG_BIDIRECTIONAL_PORT read write
				     SG_FALSE SG_FALSE close ready)))

  (define-c-proc make-custom-textual-bidirectional-port
    (id::<string> read::<procedure> write::<procedure> close
		  :optional (ready #f))
    (check-procedure-or-false make-custom-textual-bidirectional-port close)
    (check-procedure-or-false make-custom-textual-bidirectional-port ready)
    (result (Sg_MakeCustomTextualPort id SG_BIDIRECTIONAL_PORT read write
				      SG_FALSE SG_FALSE close ready)))

  ;; extra port predicates
  ;; it's rather useless because we don't get source port buffered-port
  ;; from.
  #|
  (define-c-proc file-port? (o) ::<boolean> :constant SG_FILE_PORTP)
  (define-c-proc byte-port? (o) ::<boolean> :constant SG_BYTE_PORTP)
  (define-c-proc string-port? (o) ::<boolean> :constant SG_STRING_PORTP)
  (define-c-proc custom-port? (o) ::<boolean> :constant SG_CUSTOM_PORTP)
  (define-c-proc buffered-port? (o) ::<boolean> :constant SG_BUFFERED_PORTP)
  (define-c-proc transcoded-port? (o) ::<boolean> :constant SG_TRANSCODED_PORTP)
  |#
  ;; codec

  (define-c-proc make-codec (name::<symbol> g::<procedure> p::<procedure> data)
    :no-side-effect
    Sg_MakeCustomCodecSimple)

  (define-c-proc utf-32-codec 
    (:optional (endian::<symbol> (Sg_NativeEndianness))) :no-side-effect
    (cond ((SG_EQ endian 'big)
	   (result (Sg_MakeUtf32Codec UTF_32BE)))
	  ((SG_EQ endian 'little)
	   (result (Sg_MakeUtf32Codec UTF_32LE)))
	  ((SG_EQ endian 'native)
	   (result (Sg_MakeUtf32Codec UTF_32USE_NATIVE_ENDIAN)))
	  (else
	   (assertion-violation 'utf-32-codec "unsupported endianness" 
				endian))))

  (define-c-proc port-filename (p::<port>) :no-side-effect Sg_FileName)
  (define-c-proc port-info (p::<port>) :no-side-effect
    (let ((file (Sg_FileName p))
	  (line #f)
	  (pos #f))
      (when (SG_TEXTUAL_PORTP p)
	(set! line (SG_MAKE_INT (Sg_LineNo p))))
      (when (Sg_HasPortPosition p)
	(set! pos (SG_MAKE_INT (Sg_PortPosition p))))
      (result (SG_LIST3 file line pos))))

  (define-c-proc port-reader (p::<port>) :no-side-effect SG_PORT_READER)
  
  (define-c-proc read-with-context (p::<port> ctx::<read-context>)
    (check-port-open read-with-context p)
    (check-input-port read-with-context p)
    (result (Sg_ReadWithContext p ctx)))

  (define-c-proc make-read-context 
    (:key (shared::<boolean> #f) 
	  (source-info::<boolean> #f)
	  (change-mode::<boolean> #f)
	  (no-case::<boolean> #f))
    (let ((ctx (Sg_MakeDefaultReadContext))
	  (flags::int (logior (logior (?: source-info SG_READ_SOURCE_INFO 0)
				      (?: change-mode SG_CHANGE_VM_MODE 0))
			      (?: no-case     SG_READ_NO_CASE 0))))
      (when shared (set! (-> (SG_READ_CONTEXT ctx) graph)
			 (SG_HASHTABLE (Sg_MakeHashTableSimple SG_HASH_EQ 1))))
      (set! (-> (SG_READ_CONTEXT ctx) flags) flags)
      (result ctx)))

  (define-c-proc apply-directive!
    (p::<port> directive::<symbol> :optional (ctx::<read-context> #f))
      (result (Sg_ApplyDirective p directive (?: (SG_FALSEP ctx) NULL ctx))))
  
  (define-c-proc open-output-bytevector (:optional (t::<transcoder> #f))
    (let ((bp (Sg_MakeByteArrayOutputPort -1)))
      (if (SG_FALSEP t)
	  (result bp)
	  (result (Sg_MakeTranscodedPort bp t)))))

  ;; SRFI-6
  ;; only if the given port is completely closed.
  (define-cise-stmt check-port-closed?
    ((_ name p)
     `(when (and (Sg_PortClosedP ,p) (not (Sg_PseudoPortClosedP ,p)))
	(wrong-type-of-argument-violation ',name "opened port" ,p))))
  (define-c-proc get-output-bytevector (p::<port>)
    (check-port-closed? get-output-bytevector p)
    (check-output-port get-output-bytevector p)
    (cond ((SG_BYTE_PORTP p)
	   (result (Sg_GetByteVectorFromBinaryPort (SG_BYTE_PORT p))))
	  ((and (SG_TRANSCODED_PORTP p)
		(SG_BYTE_PORTP (SG_TRANSCODED_PORT_PORT p)))
	   (result (Sg_GetByteVectorFromBinaryPort 
		    (SG_BYTE_PORT (SG_TRANSCODED_PORT_PORT p)))))
	  (else
	   (wrong-type-of-argument-violation 'get-output-bytevector
					     "binary or transcoded texutal port"
					     p))))

  (define-c-proc extract-output-bytevector (p::<port>)
    (check-port-closed? extract-output-bytevector p)
    (check-output-port extract-output-bytevector p)
    ;; I'm not quite sure if I should reset the port position
    ;; if it's textual port.
    (cond ((SG_BYTE_PORTP p)
	   (result (Sg_GetByteVectorFromBinaryPort (SG_BYTE_PORT p)))
	   (Sg_SetPortPosition p 0 SG_BEGIN)
	   (set! (ref (pointer (SG_BYTE_PORT p)) buffer start)
		 (SG_NEW byte_buffer))
	   (set! (ref (pointer (SG_BYTE_PORT p)) buffer current)
		 (ref (pointer (SG_BYTE_PORT p)) buffer start)))
	  ((and (SG_TRANSCODED_PORTP p)
		(SG_BYTE_PORTP (SG_TRANSCODED_PORT_PORT p)))
	   (result (Sg_GetByteVectorFromBinaryPort 
		    (SG_BYTE_PORT (SG_TRANSCODED_PORT_PORT p))))
	   (Sg_SetPortPosition (SG_TRANSCODED_PORT_PORT p) 0 SG_BEGIN)
	   (set! (ref (pointer (SG_BYTE_PORT (SG_TRANSCODED_PORT_PORT p)))
		      buffer start)
		 (SG_NEW byte_buffer))
	   (set! (ref (pointer (SG_BYTE_PORT (SG_TRANSCODED_PORT_PORT p)))
		      buffer current)
		 (ref (pointer (SG_BYTE_PORT (SG_TRANSCODED_PORT_PORT p)))
		      buffer start))
	   (set! (SG_TRANSCODED_PORT_UNGET p) EOF))
	  (else
	   (wrong-type-of-argument-violation 'extract-output-bytevector
					     "binary or transcoded texutal port"
					     p))))
  
  ;; these functions are for open-string-output-port
  (define-c-proc open-output-string () (result (Sg_MakeStringOutputPort 32)))

  (define-cise-stmt check-textual-port
    ((_ name p)
     `(unless (SG_TEXTUAL_PORTP ,p)
	(wrong-type-of-argument-violation ',name "textual-port" ,p))))

  ;; SRFI-6
  (define-c-proc get-output-string (p::<port>)
    (check-port-open get-output-string p)
    (check-output-port get-output-string p)
    (check-textual-port get-output-string p)
    (unless (SG_STRING_PORTP p)
      (wrong-type-of-argument-violation 'get-output-string "string port" p))
    (result (Sg_GetStringFromStringPort (SG_STRING_PORT p))))

  (define-c-proc extract-output-string (p::<port>)
    (check-port-open get-output-string p)
    (check-output-port get-output-string p)
    (check-textual-port get-output-string p)
    (unless (SG_STRING_PORTP p)
      (wrong-type-of-argument-violation 'get-output-string "string port" p))
    (result (Sg_GetStringFromStringPort (SG_STRING_PORT p)))
    (Sg_SetPortPosition p 0 SG_BEGIN)
    ;; reset
    (set! (ref (pointer (SG_STRING_PORT p)) buffer start)
	  (SG_NEW char_buffer))
    (set! (ref (pointer (SG_STRING_PORT p)) buffer current)
	  (ref (pointer (SG_STRING_PORT p)) buffer start)))

  ;; we don't check the port type
  (define-c-proc port-ready? (:optional (p (Sg_CurrentInputPort))) ::<boolean>
    (check-input-port port-ready? p)
    (result (Sg_PortReady p)))

  ;; profiler
  (define-c-proc profiler-start () ::<void> Sg_ProfilerStart)
  (define-c-proc profiler-stop () ::<fixnum> Sg_ProfilerStop)
  (define-c-proc profiler-reset () ::<void> Sg_ProfilerReset)
  (define-c-proc profiler-raw-result () Sg_ProfilerRawResult)

  (define-c-proc disasm (c::<procedure>)
    (if (SG_CLOSUREP c)
	(Sg_VMDumpCode (-> (SG_CLOSURE c) code))
	(Sg_Printf (-> (Sg_VM) logPort) (UC "subr %S") (SG_PROCEDURE_NAME c)))
    (result SG_UNDEF))

  ;; keyword
  (define-c-proc make-keyword (key::<symbol>)
    (result (Sg_MakeKeyword (-> (SG_SYMBOL key) name))))
  ;; for consistency
  (define-c-proc symbol->keyword (name::<symbol>) :constant
    (result (Sg_MakeKeyword (SG_SYMBOL_NAME name))))
  (define-c-proc string->keyword (name::<string>) :constant Sg_MakeKeyword)

  (define-c-proc keyword? (o) ::<boolean> :constant SG_KEYWORDP)

  (define-c-proc keyword->symbol (key::<keyword>) :constant
    (result (Sg_Intern (-> key name))))
  (define-c-proc keyword->string (key::<keyword>) :constant
    (result (-> key name)))

  (define-c-proc get-keyword (key::<keyword> lst :optional fallback) :constant
    Sg_GetKeyword)

  ;; cache
  (define-type <write-cache-ctx> "SgWriteCacheCtx*")
  (define-type <read-cache-ctx> "SgReadCacheCtx*")

  (define-c-proc clean-cache (:optional (target #f)) ::<void> Sg_CleanCache)
  (define-c-proc cachable? (o) ::<boolean> :constant Sg_CachableP)

  (define-c-proc scan-cache-object (o cbs ctx::<write-cache-ctx>)
    Sg_WriteCacheScanRec)

  (define-c-proc write-object-cache (o out::<port> ctx::<write-cache-ctx>)
    ::<void>
    Sg_WriteObjectCache)

  (define-c-proc read-cache-object (in::<port> ctx::<read-cache-ctx>)
    Sg_ReadCacheObject)

  (define-c-proc file->cache-file (id::<string>) :no-side-effect
    Sg_FileToCacheFile)
  
  ;; Finding library paths
  ;; this may return null or multiple library paths
  (define-c-proc library->path* (o) :no-side-effect Sg_SearchLibraryPath)
  ;; this returns #f or string.
  (define-c-proc library->path (o) :no-side-effect 
    (let ((r (Sg_SearchLibraryPath o)))
      (if (SG_NULLP r)
	  (result #f)
	  (result (SG_CAR r)))))

  ;; getenv
  (define-c-proc getenv (path::<string>) :no-side-effect
    (result (Sg_Getenv (SG_STRING_VALUE path))))

  (define-c-proc setenv (key::<string> value) ::<void>
    (let ((v::SgChar* NULL))
      (cond ((SG_STRINGP value)
	     (set! v (SG_STRING_VALUE value)))
	    ((SG_FALSEP value)) ;; NULL
	    (else
	     (wrong-type-of-argument-violation 'setenv
					       "string or #f"
					       value)))
      (Sg_Setenv (SG_STRING_VALUE key) v)))
  
  (define-c-proc getenv-alist () :no-side-effect Sg_GetenvAlist)

  (define-c-proc emergency-exit (:optional obj) ::<void>
    ;; TODO thread
    (if (SG_UNBOUNDP obj)
	(Sg_EmergencyExit EXIT_SUCCESS)
	(cond ((SG_INTP obj)
	       (Sg_EmergencyExit (SG_INT_VALUE obj)))
	      ((SG_TRUEP obj)
	       (Sg_EmergencyExit EXIT_SUCCESS))
	      (else
	       (Sg_EmergencyExit EXIT_FAILURE)))))
  
  ;; bytevector
  (define-c-proc bytevector->integer
    (bv::<bytevector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :constant
    Sg_ByteVectorToInteger)
  ;; explicit sign
  (define-c-proc bytevector->uinteger
    (bv::<bytevector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :constant
    Sg_ByteVectorToInteger)
  (define-c-proc bytevector->sinteger
    (bv::<bytevector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :constant
    Sg_ByteVectorToIntegerS)

  (define-c-proc integer->bytevector 
    (n::<integer> :optional (size::<fixnum> -1)) :no-side-effect
    Sg_IntegerToByteVector)
  ;; explicit sign
  (define-c-proc uinteger->bytevector 
    (n::<integer> :optional (size::<fixnum> -1)) :no-side-effect
    Sg_IntegerToByteVector)
  (define-c-proc sinteger->bytevector 
    (n::<integer> :optional (size::<fixnum> -1)) :no-side-effect
    Sg_SIntegerToByteVector)

  (define-c-proc bytevector-append (:rest bv-list) :no-side-effect
    Sg_ByteVectorConcatenate)
  (define-c-proc bytevector-concatenate (bv-list::<list>) :no-side-effect
    Sg_ByteVectorConcatenate)
  (define-c-proc bytevector-reverse!
    (bv::<bytevector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    Sg_ByteVectorReverseX)
  (define-c-proc bytevector-reverse
    (bv::<bytevector> :optional (start::<fixnum> 0) (end::<fixnum> -1))
    :no-side-effect
    (result (Sg_ByteVectorReverseX (Sg_ByteVectorCopy bv 0 -1) start end)))

  (define-cise-stmt check-bytevector
    ((_ name s)
     `(unless (SG_BVECTORP ,s)
	(wrong-type-of-argument-violation ',name "bytevector" ,s))))
  (define-cise-stmt bytevector-compare
    ((_ compare value name first second rest)
     `(begin
	(cond ((SG_NULLP ,rest)
	       (result (,compare (Sg_ByteVectorCmp ,first ,second) ,value)))
	      ((not (,compare (Sg_ByteVectorCmp ,first ,second) ,value))
	       (result FALSE))
	      (else
	       (let ((prev ,second))
		 (dolist (p ,rest)
		   (check-bytevector ,name p)
		   (unless (,compare (Sg_ByteVectorCmp prev p) ,value)
		     (return #f))
		   (set! prev p))
		 (result TRUE)))))))
  (define-c-proc bytevector<? (bv1::<bytevector> bv2::<bytevector> :rest rest)
    ::<boolean> :constant
    (bytevector-compare < 0 bytevector<? bv1 bv2 rest))
  (define-c-proc bytevector>? (bv1::<bytevector> bv2::<bytevector> :rest rest)
    ::<boolean> :constant
    (bytevector-compare > 0 bytevector>? bv1 bv2 rest))
  (define-c-proc bytevector<=? (bv1::<bytevector> bv2::<bytevector> :rest rest)
    ::<boolean> :constant
    (bytevector-compare <= 0 bytevector<? bv1 bv2 rest))
  (define-c-proc bytevector>=? (bv1::<bytevector> bv2::<bytevector> :rest rest)
    ::<boolean> :constant
    (bytevector-compare >= 0 bytevector>? bv1 bv2 rest))

  ;; time
  (define-c-proc time-usage () :no-side-effect Sg_VMTimeUsage)

  (define-c-proc cond-features () :no-side-effect Sg_CondFeatures)

  ;; charset
  (define-c-proc char-set? (obj) ::<boolean> :constant SG_CHAR_SET_P)

  (define-cise-stmt char-set-add
    ((_ name cs chars)
     `(dolist (ch ,chars)
	(unless (SG_CHARP ch)
	  (wrong-type-of-argument-violation 'name
					    "character" ch))
	(Sg_CharSetAddRange ,cs (SG_CHAR_VALUE ch) (SG_CHAR_VALUE ch)))))

  (define-c-proc char-set (:rest chars) :no-side-effect
    (let ((cs::SgCharSet* (SG_CHAR_SET (Sg_MakeEmptyCharSet))))
      (char-set-add char-set cs chars)
      (result cs)))

  (define-c-proc char-set-copy (cs::<char-set>) :no-side-effect Sg_CharSetCopy)

  (define-c-proc char-set-contains? (cs::<char-set> ch::<char>) ::<boolean>
    :no-side-effect
    Sg_CharSetContains)

  (define-c-proc %char-set-equal? (x::<char-set> y::<char-set>) ::<boolean>
    :no-side-effect
    Sg_CharSetEq)

  (define-c-proc %char-set<=? (x::<char-set> y::<char-set>) ::<boolean>
    :no-side-effect
    Sg_CharSetLe)

  (define-c-proc %char-set-add-chars! (cs::<char-set> chars)
    (char-set-add %char-set-add-chars! cs chars) (result cs))

  (define-c-proc %char-set-add-range! (cs::<char-set> from to)
    (let ((f::long -1) (t::long -1))
      (cond ((SG_INTP from) (set! f (SG_INT_VALUE from)))
	    ((SG_CHARP from) (set! f (SG_CHAR_VALUE from))))
      (when (< f 0)
	(wrong-type-of-argument-violation '%char-set-add-range!
					  "character or positive exact integer"
					  from))
      (when (> f SG_CHAR_MAX)
	(assertion-violation '%char-set-add-range!
			     "'from' argument out of range" from))
      (cond ((SG_INTP to) (set! t (SG_INT_VALUE to)))
	    ((SG_CHARP to) (set! t (SG_CHAR_VALUE to))))
      (when (< t 0)
	(wrong-type-of-argument-violation '%char-set-add-range!
					  "character or positive exact integer"
					  to))
      (when (> t SG_CHAR_MAX)
	(assertion-violation '%char-set-add-range!
			     "'to' argument out of range" to))
      (result (Sg_CharSetAddRange cs (SG_CHAR f) (SG_CHAR t)))))

  (define-c-proc %char-set-add! (dst::<char-set> src::<char-set>) Sg_CharSetAdd)
  (define-c-proc %char-set-complement! (cs::<char-set>) Sg_CharSetComplement)
  (define-c-proc %char-set-ranges (cs::<char-set>) Sg_CharSetRanges)

  ;;; Reader macro related
  (define-c-proc %get-macro-character (c::<char> p::<port>)
    (result (Sg_GetMacroCharacter c (Sg_PortReadTable p))))

  (define-c-proc %set-macro-character
    (c::<char> proc::<procedure> non_termP::<boolean> p::<port>) ::<void>
    (Sg_SetMacroCharacter c proc non_termP (Sg_EnsureCopiedReadTable p)))

  (define-c-proc %make-dispatch-macro-character
    (c::<char> non_termP::<boolean> p::<port>) ::<boolean>
    (result (Sg_MakeDispatchMacroCharacter 
	     c non_termP (Sg_EnsureCopiedReadTable p))))

  (define-c-proc %get-dispatch-macro-character 
    (c::<char> subc::<char> p::<port>)
    (result (Sg_GetDispatchMacroCharacter c subc (Sg_PortReadTable p))))

  (define-c-proc %set-dispatch-macro-character 
    (c::<char> subc::<char> proc::<procedure> p::<port>) ::<void>
    (Sg_SetDispatchMacroCharacter 
     c subc proc (Sg_EnsureCopiedReadTable p)))
  
  (define (get-macro-character c)
    (%get-macro-character c (current-loading-port)))

  (define (set-macro-character c proc :optional (non-term? #f))
    (%set-macro-character c proc non-term? (current-loading-port)))

  (define (make-dispatch-macro-character c :optional (non-term? #f))
    (%make-dispatch-macro-character c non-term? (current-loading-port)))

  (define (get-dispatch-macro-character c subc)
    (%get-dispatch-macro-character c subc (current-loading-port)))
  
  (define (set-dispatch-macro-character c subc proc)
    (set-dispatch-macro-character c subc (current-loading-port)))

  ;; for (sagittarius reader) library's define-reader-macro related
  (define-c-proc %insert-macro-character
    (c::<char> proc::<procedure> lib::<library>
	       :optional (non_termP::<boolean> #f))
    ::<void>
    (Sg_EnsureLibraryReadTable lib)
    (Sg_SetMacroCharacter c proc non_termP
			  (SG_LIBRARY_READTABLE lib)))

  (define-c-proc %insert-dispatch-macro-character
    (c::<char> subc::<char> proc::<procedure> lib::<library>
	       :optional (non_termP::<boolean> #f))
    ::<void>
    (Sg_EnsureLibraryReadTable lib)
    (Sg_MakeDispatchMacroCharacter c non_termP
				   (SG_LIBRARY_READTABLE lib))
    (Sg_SetDispatchMacroCharacter c subc proc (SG_LIBRARY_READTABLE lib)))

  (define-c-proc %library-reader-set! (lib::<library> proc::<procedure>)
    ::<void>
    ;; TODO should we forbid overwrite?
    (set! (SG_LIBRARY_READER lib) proc))

  (define-c-proc read-delimited-list 
    (c::<char> :optional
	       (p::<port> (Sg_CurrentInputPort))
	       (shareP::<boolean> #t))
    (return (Sg_ReadDelimitedList p c shareP)))

  (define-c-proc %delimited-char? (c::<char> p::<port>)
    ::<boolean> :no-side-effect
    Sg_DelimitedCharP)
  (define (delimited-char? c) (%delimited-char? c (current-loading-port)))

  (define-c-proc constant-literal? (o) ::<boolean> :constant
    Sg_ConstantLiteralP)

  (define-c-proc digit-value (c::<char>) Sg_DigitValue)

  ;; weak objects
  (define-c-proc weak-box? (o) ::<boolean> :constant SG_WEAK_BOXP)
  (define-c-proc make-weak-box (o) :no-side-effect Sg_MakeWeakBox)
  (define-c-proc weak-box-empty? (wb::<weak-box>) ::<boolean> :no-side-effect
    Sg_WeakBoxEmptyP)
  (define-c-proc weak-box-set! (wb::<weak-box> o) ::<void> Sg_WeakBoxSet)
  (define-c-proc weak-box-ref (wb::<weak-box> :optional fallback) 
    :no-side-effect (setter weak-box-set!)
    ;; this may return NULL so check it
    (let ((o (Sg_WeakBoxRef wb)))
      (cond (o (result o))
	    ((SG_UNBOUNDP fallback) (result SG_FALSE))
	    (else (result fallback)))))

  (define-c-proc weak-vector? (o) ::<boolean> :constant SG_WEAK_VECTORP)
  (define-c-proc make-weak-vector (size::<fixnum>) Sg_MakeWeakVector)

  (define-c-proc weak-vector-length (o) ::<fixnum> :no-side-effect
    (unless (SG_WEAK_VECTORP o)
      (wrong-type-of-argument-violation 'weak-vector-length
					"weak-vector" o))
    (result (-> (SG_WEAK_VECTOR o) size)))

  (define-c-proc weak-vector-ref (wvec k::<fixnum> :optional fallback)
    :no-side-effect (setter weak-vector-set!)
    (unless (SG_WEAK_VECTORP wvec)
      (wrong-type-of-argument-violation 'weak-vector-ref
					"weak-vector" wvec))
    (cond ((or (< k 0) (>= k (-> (SG_WEAK_VECTOR wvec) size)))
	   (if (SG_UNBOUNDP fallback)
	       (assertion-violation 'weak-vector-ref
				    "index out of range" 
				    (SG_LIST2 wvec (SG_MAKE_INT k)))
	       (result fallback)))
	  (else
	   (result (Sg_WeakVectorRef wvec k fallback)))))

  (define-c-proc weak-vector-set! (wvec k::<fixnum> value) ::<void>
    (unless (SG_WEAK_VECTORP wvec)
      (wrong-type-of-argument-violation 'weak-vector-ref
					"weak-vector" wvec))
    (when (or (< k 0) (>= k (-> (SG_WEAK_VECTOR wvec) size)))
      (assertion-violation 'weak-vector-ref
			   "index out of range" 
			   (SG_LIST2 wvec (SG_MAKE_INT k))))
    (Sg_WeakVectorSet wvec k value))

  ;; for now until eqv
  ;; TODO ugly copy paste with almost the same...
  (define-cise-stmt %make-weak-hashtable
    ((_ who type weakness init-size default)
     `(let ((w::SgWeakness (retrieve-weakness ,weakness))
	    (v SG_UNDEF)
	    (k::long -1))
	(cond ((SG_INTP ,init-size) (set! k (SG_INT_VALUE ,init-size)))
	      ((SG_FALSEP ,init-size) (set! k 200))
	      (else 
	     (wrong-type-of-argument-violation 'who
					       "#f or fixnum" ,init-size)))
	(unless (SG_UNBOUNDP ,default) (set! v ,default))
	(result (Sg_MakeWeakHashTableSimple ,type w k v)))))

  (define-c-proc make-weak-eq-hashtable 
    (:key (init-size #f) (weakness::<symbol> both) default)
    :no-side-effect
    (%make-weak-hashtable 'make-weak-eq-hashtable
			  SG_HASH_EQ weakness init-size default))

  (define-c-proc make-weak-eqv-hashtable 
    (:key (init-size #f) (weakness::<symbol> both) default)
    :no-side-effect
    (%make-weak-hashtable 'make-weak-eqv-hashtable
			  SG_HASH_EQV weakness init-size default))
  (define-c-proc make-weak-equal-hashtable 
    (:key (init-size #f) (weakness::<symbol> both) default)
    :no-side-effect
    (%make-weak-hashtable 'make-weak-equal-hashtable
			  SG_HASH_EQUAL weakness init-size default))
  (define-c-proc make-weak-string-hashtable 
    (:key (init-size #f) (weakness::<symbol> both) default)
    :no-side-effect
    (%make-weak-hashtable 'make-weak-string-hashtable
			  SG_HASH_STRING weakness init-size default))

  (define-c-proc make-weak-hashtable 
    (hasher::<procedure> equiv::<procedure>
			 :key (init-size #f)
			      (weakness::<symbol> both) 
			      default)
    :no-side-effect

    (let ((w::SgWeakness (retrieve-weakness weakness))
	  (v SG_UNDEF)
	  (k::long -1))
      (cond ((SG_INTP init-size) (set! k (SG_INT_VALUE init-size)))
	    ((SG_FALSEP init-size) (set! k 200))
	    (else 
	     (wrong-type-of-argument-violation 'make-weak-hashtable
					       "#f or fixnum" init-size)))
      (unless (SG_UNBOUNDP default) (set! v default))
      (result (Sg_MakeWeakHashTable hasher equiv w k v))))

  (define-c-proc weak-hashtable? (o) ::<boolean> :constant SG_WEAK_HASHTABLE_P)

  (define-c-proc weak-hashtable-ref 
    (wh::<weak-hashtable> key :optional (fallback #f)) :no-side-effect
    (setter weak-hashtable-set!)
    (result (Sg_WeakHashTableRef wh key fallback)))

  (define-c-proc weak-hashtable-set! (wh::<weak-hashtable> key value) ::<void>
    (Sg_WeakHashTableSet wh key value 0))

  (define-c-proc weak-hashtable-delete! (wh::<weak-hashtable> key) ::<void>
    Sg_WeakHashTableDelete)

  (define-c-proc weak-hashtable-keys-list (wh::<weak-hashtable>) :no-side-effect
    Sg_WeakHashTableKeys)

  (define-c-proc weak-hashtable-values-list (wh::<weak-hashtable>)
    :no-side-effect
    Sg_WeakHashTableValues)

  (define-c-proc weak-hashtable-copy (wh::<weak-hashtable>) :no-side-effect
    Sg_WeakHashTableCopy)

  (define-c-proc weak-hashtable-shrink (wh::<weak-hashtable>) ::<fixnum>
    Sg_WeakHashTableShrink)

  (define-c-proc microsecond ()
    (let ((sec::ulong 0)
	  (usec::ulong 0))
      (Sg_GetTimeOfDay (& sec) (& usec))
      (result (Sg_MakeIntegerFromS64 (+ (* (cast int64_t sec) 1000000) usec)))))

  ;; fixnum may return different result (32bit/64bit thing)
  (define-c-proc immediate? (o) ::<boolean> :no-side-effect
    (result (not (SG_PTRP o))))

  (define-c-proc get-mac-address (:optional (pos::<fixnum> 0)) :no-side-effect
    Sg_GetMacAddress)

  (define-c-proc uname () :no-side-effect Sg_Uname)

  (define-c-proc sagittarius-sitelib-directory () :no-side-effect Sg_SitelibPath)

  ;; for convenience.
  (define-c-proc gc () ::<void> Sg_GC)

  ;; Do not use directly!!
  (define-c-proc %port-data (p::<port>) (setter %set-port-data!) SG_PORT_DATA)
  (define-c-proc %set-port-data! (p::<port> v) ::<void>
    (set! (SG_PORT_DATA p) v))

  ;; system call
  (define-cise-stmt check-redirect
    ((_ val in?)
     `(begin
	(unless (or (SG_EQ ,val :pipe)
		    (SG_EQ ,val :stdin)
		    (SG_EQ ,val :stdout)
		    (SG_EQ ,val :stderr)
		    (SG_EQ ,val :null)
		    (SG_STRINGP ,val))
	  (assertion-violation 'sys-process-call
			       "redirect keyword must be one of :pipe, :stdin, :stdout, :stderr or string which must be a file path" ,val))
	(when (and ,in? (or (SG_EQ ,val :stdout) (SG_EQ ,val :stderr)))
	  (assertion-violation 'sys-process-call
			       "redirect input must not have :stdout or :stderr"
			       ,val)))))

  (define-c-proc sys-process-call 
    (name::<string> args::<list> :key (directory #f) (detach? #f)
		    (input :pipe) (output :pipe) (error :pipe))
    (dolist (arg args)
      (unless (SG_STRINGP arg)
	(wrong-type-of-argument-violation 'sys-process-call
					  "arguments must be a list of string"
					  args)))
    (unless (or (SG_STRINGP directory) (SG_FALSEP directory))
      (wrong-type-of-argument-violation 'sys-process-call
					"string or #f" directory))
    (check-redirect input TRUE)
    (check-redirect output FALSE)
    (check-redirect error FALSE)
    (let ((in input) (out output) (err error))
      (let* ((flags::int 0)
	     (d::SgString* NULL)
	     (handle::uintptr_t 0))
	(when (not (SG_FALSEP detach?)) 
	  (set! flags (logior flags SG_PROCESS_DETACH)))
	(when (SG_STRINGP directory) (set! d (SG_STRING directory)))
	(set! handle (Sg_SysProcessCall name args 
					(& in) (& out) (& err)
					d flags))
	(.if "SIZEOF_VOIDP >= 8"
	     (result (Sg_Values4 (Sg_MakeIntegerFromU64 handle) in out err))
	     (result (Sg_Values4 (Sg_MakeIntegerU handle) in out err))))))

  (decl-code (.typedef "struct timespec" "timespec_t"))
  (define-c-proc sys-process-wait (pid::<integer> :key (timeout #f))
    (let ((ts::timespec_t)
	  (pts::timespec_t*))
      (set! pts (Sg_GetTimeSpec timeout (& ts)))
      (.if "SIZEOF_VOIDP >= 8"
	   (result (Sg_SysProcessWait
		    (cast uintptr_t 
			  (Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))
		    pts))
	   (result (Sg_SysProcessWait
		    (cast uintptr_t 
			  (Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))
		    pts)))))

  (define-c-proc sys-process-kill (pid::<integer> :key (children? #f))
    ::<fixnum>
    (.if "SIZEOF_VOIDP >= 8"
	 (result (Sg_SysProcessKill
	     (cast uintptr_t (Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))
	     (not (SG_FALSEP children?))))
	 (result (Sg_SysProcessKill
	     (cast uintptr_t (Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))
	     (not (SG_FALSEP children?))))))

  (define-c-proc sys-process-active? (pid::<integer>) ::<boolean>
    (.if "SIZEOF_VOIDP >= 8"
	 (result (Sg_SysProcessAcriveP
	     (cast uintptr_t (Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))))
	 (result (Sg_SysProcessAcriveP
	     (cast uintptr_t (Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))))))

  ;; cpu-count
  (define-c-proc cpu-count () ::<fixnum> Sg_CPUCount)

  (define-c-proc get-process-times () :no-side-effect Sg_GetProcessTimes)
  (define-c-proc get-thread-times (:optional (vm::<thread> (Sg_VM)))
    :no-side-effect Sg_GetThreadTimes)
  
  ;; compare
  (define-c-proc compare (x y) ::<fixnum> :no-side-effect Sg_Compare)

  
  ;; only equality argument must be a procedure.
  (define-c-proc %make-comparator (type-test eq::<procedure>
				   comparison hash name)
    :no-side-effect Sg_MakeComparator)
  (define-c-proc comparator? (o) ::<boolean> :constant SG_COMPARATORP)
  ;; can we make this constant?
  (define-c-proc comparator-comparison-procedure? (c::<comparator>)
    ::<boolean> :constant
    (result (not (logand (-> c flags) SG_COMPARATOR_NO_ORDER))))
  (define-c-proc comparator-hash-function? (c::<comparator>)
    ::<boolean> :constant
    (result (not (logand (-> c flags) SG_COMPARATOR_NO_HASH))))

  (define-c-proc comparator-type-test-procedure (c::<comparator>) :constant
    (result (-> c typeFn)))
  (define-c-proc comparator-equality-predicate (c::<comparator>) :constant
    (result (-> c eqFn)))
  (define-c-proc comparator-comparison-procedure (c::<comparator>) :constant
    (result (-> c compFn)))
  (define-c-proc comparator-hash-function (c::<comparator>) :constant
    (result (-> c hashFn)))

  ;; for performance
  (define-c-proc comparator-test-type (c::<comparator> obj) :constant
    (if (logand (-> c flags) SG_COMPARATOR_ANY_TYPE)
	(result SG_TRUE)
	(result (Sg_VMApply1 (-> c typeFn) obj))))

  (define-cfn comparator-check-type-cc (result data::void**) :static
     (when (SG_FALSEP result)
       (let* ([c   (SG_OBJ (aref data 0))]
	      [obj (SG_OBJ (aref data 1))])
	 (Sg_Error (UC "Comparator %S cannot accept object %S") c obj)))
     (return SG_TRUE))

  (define-c-proc comparator-check-type (c::<comparator> obj) :constant
    (if (logand (-> c flags) SG_COMPARATOR_ANY_TYPE)
	(result SG_TRUE)
	(let* ([data::(.array void* (2))])
	  (set! (aref data 0) c)
	  (set! (aref data 1) obj)
	  (Sg_VMPushCC comparator-check-type-cc data 2)
	  (result (Sg_VMApply1 (-> c typeFn) obj)))))

  (define-c-proc comparator-equal? (c::<comparator> a b) :constant
    (result (Sg_VMApply2 (-> c eqFn) a b)))

  (define-c-proc comparator-compare (c::<comparator> a b) :constant
    (result (Sg_VMApply2 (-> c compFn) a b)))

  (define-c-proc comparator-hash (c::<comparator> x) :constant
    (result (Sg_VMApply1 (-> c hashFn) x)))

  (define-c-proc %eq-comparator () Sg_EqComparator)
  (define-c-proc %eqv-comparator () Sg_EqvComparator)
  (define-c-proc %equal-comparator () Sg_EqualComparator)
  (define-c-proc %string-comparator () Sg_StringComparator)

  ;; hashtable using comparator
  (define-c-proc make-hashtable/comparator 
    (c::<comparator> :optional (k::<fixnum> 200)) :no-side-effect
    Sg_MakeHashTableWithComparator)

)
