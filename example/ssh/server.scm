#!read-macro=sagittarius/bv-string
(import (rnrs)
	(rnrs eval)
	(clos user)
	(sagittarius pam)
	(sagittarius pty)
	(sagittarius stty)
	(sagittarius termios)
	(sagittarius socket)
	(sagittarius crypto keys)
	(sagittarius object)
	(rfc ssh) ;; for types and client
	(rfc ssh server)
	(srfi :18)
	(getopt))

(define-class <pam-token> (<ssh-auth-ticket>)
  ((token :init-keyword :token)))
(define-class <passwd-token> (<ssh-auth-ticket>)
  ((token :init-keyword :token)))

(define-method ssh-invalidate-auth-ticket ((t <pam-token>))
  (pam-invalidate-token! (~ t 'token)))

(define-method ssh-userauth-supported-methods (username)
  (list +ssh-auth-method-keyboard-interactive+
	+ssh-auth-method-public-key+))
(define-method ssh-authenticate-user ((m (equal +ssh-connection+))
				      (cred <ssh-interactive-credential>))
  (define ((make-conversation cred) prompt)
    ((ssh-credential-prompt-sender cred)
     (vector-map (lambda (p)
		   (make-ssh-interactive-prompt (cdr p) (eq? 'echo-on (car p))))
		 prompt))
    ((ssh-credential-response-receiver cred)))
  (define conv (make-conversation cred))
  (cond ((pam-authenticate "login" (ssh-credential-username cred) conv) =>
	 (lambda (token) (make <pam-token> :token token)))
	(else #f)))

(define-method ssh-authenticate-user ((m (equal +ssh-connection+))
				      (cred <ssh-pubic-key-credential>))
  ;; check if the public key is known :)
  ;; for this, we don't accept RSA :D
  (and (not (rsa-public-key? (ssh-credential-public-key cred)))
       (make <passwd-token> :token (get-passwd (ssh-credential-username cred)))))

(define (decode-opcode attr bv)
  (define (opcode->command opcode)
    (case opcode
      ((1)   'intr)
      ((2)   'quit)
      ((3)   'erase)
      ((4)   'kill)
      ((5)   'eof)
      ((6)   'eol)
      ((7)   'eol2)
      ((8)   'star)
      ((9)   'stop)
      ((10)  'susp)
      ((11)  'dsusp)
      ((12)  'reprint)
      ((13)  'werase)
      ((14)  'lnext)
      ;; not supported by (sagittarius stty)
      ;;((15)  'flush)
      ;;((16)  'switch)
      ((17)  'status)
      ((18)  'discard)
      ((30)  'ignpar)
      ((31)  'parmrk)
      ((32)  'inpck)
      ((33)  'istrip)
      ((34)  'inlcr)
      ((35)  'igncr)
      ((36)  'icrnl)
      ;; not supported by (sagittarius stty)
      ;;((37)  'iuclc)
      ((38)  'ixon)
      ((39)  'ixany)
      ((40)  'ixoff)
      ((41)  'imaxbel)
      ((42)  'iutf8)
      ((50)  'isig)
      ((51)  'icanon)
      ;; not supported by (sagittarius stty)
      ;;((52)  'xcase)
      ((53)  'echo)
      ((54)  'echoe)
      ((55)  'echok)
      ((56)  'echonl)
      ((57)  'noflsh)
      ((58)  'tostop)
      ((59)  'iexten)
      ((60)  'echoctl)
      ((61)  'echoke)
      ((62)  'pendin)
      ((70)  'opost)
      ((71)  'onlcr)
      ((72)  'onocr)
      ((73)  'ocrnl)
      ((74)  'onocr)
      ((75)  'onlret)
      ((90)  'cs7)
      ((91)  'cs8)
      ((92)  'parenb)
      ((93)  'parodd)
      ((128) 'ispeed)
      ((129) 'ospeed)
      (else  #f)))
  (define (char-command? c)
    (memq c '(eof eol eol2 erase intr kill quit susp star stop 
	      werase lnext dsusp status discard reprint)))
  (define (special-command? c) (memq c '(min time ispeed ospeed)))
  (define (setup-speed termios ispeed ospeed)
    (and ispeed (sys-cfsetispeed termios ispeed))
    (and ospeed (sys-cfsetospeed termios ospeed))
    termios)
  (define (opcode->setting opcode v)
    (let ((c (opcode->command opcode)))
      (cond ((not c) #f)
	    ((char-command? c) `(,c ,(integer->char v)))
	    ((special-command? c) `(,c ,v))
	    ((zero? v) `(not ,c))
	    (else c))))
  (let loop ((setting '()) (offset 0))
    (let ((op (bytevector-u8-ref bv (+ offset 0))))
      (if (zero? op) ;; TTY_OP_END
	  (stty-compose-termios! attr setting)
	  (let* ((v (bytevector-u32-ref bv (+ offset 1) (endianness big)))
		 (s (opcode->setting op v)))
	    (loop (if s (cons s setting) setting)
		  (+ offset 5)))))))

(define-method ssh-handle-channel-request
  ((m (equal "pty-req")) channel ignore bv)
  (define msg (bytevector->ssh-message <ssh-msg-channel-pty-request> bv))
  (define pty (make-pty))
  (define termios (decode-opcode (pty-termios pty) (~ msg 'mode)))
  (pty-resize! pty (~ msg 'width) (~ msg 'height))
  (ssh-channel-put-attribute! channel 'pty pty)
  #t)

(define-method ssh-handle-channel-request
  ((m (equal "env")) channel ignore bv)
  ;; Do nothing
  #t)

(define-method ssh-handle-channel-request
  ((m (equal "window-change")) channel ignore bv)
  (define msg (bytevector->ssh-message <ssh-msg-channel-window-change> bv))
  (define pty (ssh-channel-ref-attribute channel 'pty))
  (when pty (pty-resize! pty (~ msg 'width) (~ msg 'height)))
  #t)

(define-method ssh-handle-channel-request
  ((m (equal "shell")) channel ignore bv)
  (define pty (ssh-channel-ref-attribute channel 'pty))
  (define (input-thread in)
    (define (loop)
      (define buf (make-bytevector 1))
      (let lp ()
	(let ((u8 (get-u8 in)))
	  (cond ((eof-object? u8)
		 (pty-close! pty)
		 (close-ssh-channel channel))
		(else
		 (bytevector-u8-set! buf 0 u8)
		 (ssh-deliver-channel-data channel buf)
		 (lp))))))
    (make-thread loop))
  (define (pty-data-handler)
    (define ticket (ssh-server-connection-auth-ticket
		    (ssh-channel-connection channel)))
    (define token (~ ticket 'token))
    (define passwd (if (auth-token? token)
		       (auth-token-passwd token)
		       token))
    (pty-spawn! pty (passwd-shell passwd) '()
		:user token :directory (passwd-dir passwd))
    (let* ((in (pty-input-port pty))
	   (out (pty-output-port pty))
	   (thread (input-thread in)))
      (ssh-channel-put-attribute! channel 'shell-input-thread thread)
      (ssh-channel-after-channel-request! channel
	(lambda () (thread-start! thread)))
      (lambda (c data start count)
	(when (and data (not (pty-closed? pty)))
	  (put-bytevector out data start count)))))
  (pty-data-handler))

(define (run-server host-key)
  (define server-socket (make-server-socket "9999"))
  (define server-port (socket-info-port (socket-info server-socket)))

  (define (event-loop transport)
    (let loop ((packet (ssh-read-packet transport)))
      (cond ((ssh-server-handle-packet transport packet)
	     (unless (ssh-packet-msg-disconnect? packet)
	       (loop (ssh-read-packet transport))))
	    (else
	     (close-server-ssh-transport!
	      transport +ssh-disconnect-service-not-available+)))))

  (print "Port " server-port)
  (print "To terminate: Ctrl-C")
  (let loop ((socket (socket-accept server-socket)))
    (let ((transport (socket->server-ssh-transport
		      socket (list (key-pair->ssh-host-key host-key)))))
      (guard (e (else
		 (socket-shutdown socket SHUT_RDWR)
		 (socket-close socket)
		 (raise e)))
	(event-loop transport))
      (loop (socket-accept server-socket)))))

(define (usage)
  (print "server.scm -i openssh_id_file")
  (exit -1))

(define (from-console)
  (display "pass phrase> ") (flush-output-port (current-output-port))
  (with-stty '((not echo) echonl) (lambda () (get-line (current-input-port)))))

(define (main args)
  (with-args (cdr args)
      ((id-file (#\i "id") #t (usage)))
    (define password (from-console))
    (define host-key (ssh-read-identity-file id-file password))
    (guard (e (else (report-error e)))
      (run-server host-key))
    (socket-close server-socket)))

