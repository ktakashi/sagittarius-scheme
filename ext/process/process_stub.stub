;; -*- scheme -*-
(decl-code
 (.include <sagittarius.h>)
 (.if "defined(_WIN32)"
      (.include <windows.h>)
      (.include <sys/types.h>
		<unistd.h>))
 (.define "LIBSAGITTARIUS_EXT_BODY")
 (.include <sagittarius/extend.h>)
 (.include <sagittarius-process.h>))

(define-type <shared-memory> "SgSharedMemory*")

(define-cise-stmt assertion-violation
  ((_ who msg)
   `(begin
      (Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) SG_UNBOUND)))
  ((_ who msg irritants)
   `(begin
      (Sg_AssertionViolation ,who (SG_MAKE_STRING ,msg) ,irritants)
      )))

(define-cise-stmt wrong-type-of-argument-violation
  ((_ who msg got)
   `(begin
      (Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg)
				       ,got SG_UNBOUND)))
  ((_ who msg got irritants)
   `(begin
      (Sg_WrongTypeOfArgumentViolation ,who (SG_MAKE_STRING ,msg)
				       ,got ,irritants))))


(define-c-proc getpid () ::<fixnum>
  (.if "defined(_WIN32)"
       (result (GetCurrentProcessId()))
       (result (getpid))))

(define-c-proc %pid->sys-process (pid::<fixnum>)
  (.if "SIZEOF_VOIDP == 8"
       (result (Sg_MakeIntegerFromU64 (Sg_PidToSysProcess pid)))
       (result (Sg_MakeIntegerU (Sg_PidToSysProcess pid)))))

(define-c-proc shared-memory? (o) ::<boolean> SG_SHARED_MEMORY_P)
(define-c-proc shared-memory->bytevector (shm::<shared-memory>)
  (result (-> shm memory)))

(define-cfn get-open-flags (option no-fail::int*) ::int :static
  (let* ((opt (Sg_SlotRefUsingClass (Sg_ClassOf option) option 'members))
	 (no-create?::int (not (SG_FALSEP (Sg_Memq 'no-create opt))))
	 (no-truncate?::int (not (SG_FALSEP (Sg_Memq 'no-truncate opt))))
	 (no-fail?::int (not (SG_FALSEP (Sg_Memq 'no-fail opt)))))
    (when no-fail? (set! (pointer no-fail) no-fail?))
    (cond ((and no-create? no-truncate?) (return 0)) ;; 
	  (no-create? (return SG_TRUNCATE))
	  (no-truncate? (return SG_CREATE))
	  ;; if only no-fail is specified
	  (else (return (logior SG_CREATE SG_TRUNCATE))))))
    

(define-c-proc open-shared-memory (name::<string> size::<fixnum>
				   :optional (option #f))
  (unless (or (SG_FALSEP option) (Sg_RecordP option))
    (Sg_AssertionViolation 'open-shared-memory
			   (SG_MAKE_STRING "invalid option") 
			   (SG_LIST1 option)))
  (let ((no-fail?::int FALSE)
	(flags::int (?: (SG_FALSEP option) 
			;; default create.
			;; so creation does truncate the shared memory
			(logior SG_CREATE SG_TRUNCATE)
			(get-open-flags option (& no-fail?)))))
    ;; it won't fail if we specify this
    (when no-fail? (set! flags (logior flags SG_CREATE)))
    (result (Sg_OpenSharedMemory name size flags))))

;; moved from lib_sagittarius.stub
(define-c-proc close-shared-memory (shm::<shared-memory>)
  Sg_CloseSharedMemory)

  ;; system call
  (define-cise-stmt check-redirect
    ((_ val in?)
     `(begin
	(unless (or (SG_EQ ,val :pipe)
		    (SG_EQ ,val :stdin)
		    (SG_EQ ,val :stdout)
		    (SG_EQ ,val :stderr)
		    (SG_EQ ,val :null)
		    (SG_STRINGP ,val))
	  (assertion-violation 'sys-process-call
			       "redirect keyword must be one of :pipe, :stdin, :stdout, :stderr or string which must be a file path" ,val))
	(when (and ,in? (or (SG_EQ ,val :stdout) (SG_EQ ,val :stderr)))
	  (assertion-violation 'sys-process-call
			       "redirect input must not have :stdout or :stderr"
			       ,val)))))

(define-c-proc sys-process-call 
  (name::<string> args::<list> :key (directory #f) (detach? #f)
		  (input :pipe) (output :pipe) (error :pipe) (token #f))
  (dolist (arg args)
    (unless (SG_STRINGP arg)
      (wrong-type-of-argument-violation 'sys-process-call
					"arguments must be a list of string"
					args)))
  (unless (or (SG_STRINGP directory) (SG_FALSEP directory))
    (wrong-type-of-argument-violation 'sys-process-call
				      "string or #f" directory))
  (check-redirect input TRUE)
  (check-redirect output FALSE)
  (check-redirect error FALSE)
  (let ((in input) (out output) (err error))
    (let* ((flags::int 0)
	   (d::SgString* NULL)
	   (handle::uintptr_t 0))
      (when (not (SG_FALSEP detach?)) 
	(set! flags (logior flags SG_PROCESS_DETACH)))
      (when (SG_STRINGP directory) (set! d (SG_STRING directory)))
      (set! handle (Sg_SysProcessCallAs name args 
					(& in) (& out) (& err)
					d token flags))
      (.if "SIZEOF_VOIDP >= 8"
	   (result (Sg_Values4 (Sg_MakeIntegerFromU64 handle) in out err))
	   (result (Sg_Values4 (Sg_MakeIntegerU handle) in out err))))))

(decl-code (.typedef "struct timespec" "timespec_t"))
(define-c-proc sys-process-wait (pid::<integer> :key (timeout #f))
  (let ((ts::timespec_t)
	(pts::timespec_t*))
    (set! pts (Sg_GetTimeSpec timeout (& ts)))
    (.if "SIZEOF_VOIDP >= 8"
	 (result (Sg_SysProcessWait
		  (cast uintptr_t 
			(Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))
		  pts))
	 (result (Sg_SysProcessWait
		  (cast uintptr_t 
			(Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))
		  pts)))))

(define-c-proc sys-process-kill (pid::<integer> :key (children? #f)) ::<fixnum>
  (.if "SIZEOF_VOIDP >= 8"
       (result (Sg_SysProcessKill
		(cast uintptr_t (Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))
		(not (SG_FALSEP children?))))
       (result (Sg_SysProcessKill
		(cast uintptr_t (Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))
		(not (SG_FALSEP children?))))))

(define-c-proc sys-process-active? (pid::<integer>) ::<boolean>
  (.if "SIZEOF_VOIDP >= 8"
       (result (Sg_SysProcessAcriveP
		(cast uintptr_t (Sg_GetIntegerU64Clamp pid SG_CLAMP_NONE NULL))))
       (result (Sg_SysProcessAcriveP
		(cast uintptr_t (Sg_GetUIntegerClamp pid SG_CLAMP_NONE NULL))))))
