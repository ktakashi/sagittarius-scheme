;; -*- mode: scheme; coding: utf-8 -*-

;; basic strategy of renaming input expression.
;; 
;; the implementation of syntax-case depending on the behaviours of
;; free-identifier=? and bound-identifier=?. when we need to consider
;; what's bound to the target identifier, then we need to use
;; free-identifier=?. Otherwise bound-identifier=? to simply compare
;; if the identifier is created in the same macro expansion process.
;; 
;; renaming identifiers or symbols are mostly straightforward. we
;; simply rename given symbols or identifiers except if the given
;; identifier is pending identifier or pattern variable. pending
;; identifier is a type of identifier which will be create during
;; syntax (#') compilation. this identifier may or may not be
;; renamed (the name of the identifier itself will be changed) by
;; the compiler to make macro somewhat hygienic. this renaming process
;; depends on the identity (in sense of eq?) of the identifier. so we
;; can't rename it twice unless it's absolutely needed.
;; pattern variables need to be treated a bit specially. they are
;; basically not renamed once it's created. so whenever renaming
;; process is run it needs to be considered. however the renamed
;; identifier of pattern variable does not have any mark to determine
;; whether or not it's pattern identifier. so we need to look up
;; compiler environment. comparing pattern identifier must always
;; be done by in sense of bound-identifier=?. 
;; matching pattern variable and literals must always be done by 
;; in sense of bound-identifier=?. consider the following case:
;;
;;   (define-syntax foo
;;     (syntax-rules ()
;;       ((_ a b)
;;        (let-syntax ((bar (syntax-rules (a)
;;                            ((_ b) 'ok)
;;                            ((_ d) 'ng))))
;;          (bar d)))
;;       ((_ x ...)
;;        (foo x ... t))))
;; 
;; the literal 'a' (actual value is 't') is generated by the macro 
;; expansion and the 'b' of syntax pattern '(_ b)' (actual value is
;; '(_ t)') is created in different macro expansion process. in this
;; case if we compare them in sense of free-identifier=? then it
;; return #t but that's not correct. comparing pattern and literals
;; with bound-identifier=? should always succeed since we preserve
;; renamed pattern variables.

;; #!nounbound check argument counts against previously bound procedure,
;; if we need to change procedure signature, we need to disable it...
;; enable it later version...
;;#!nounbound
(library (core macro)
    (export compile-syntax-case compile-syntax
	    current-usage-env current-macro-env
	    make-macro-transformer
	    variable-transformer?
	    make-core-parameter
	    make-identifier
	    ;; aboves are needed for compiler
	    make-variable-transformer
	    free-identifier=? bound-identifier=?
	    datum->syntax syntax->datum generate-temporaries
	    er-macro-transformer

	    LEXICAL PATTERN BOUNDARY)
    (import (core)
	    (core base)
	    (core errors)
	    (for (compat r7rs) expand)
	    (except (sagittarius) er-macro-transformer)
	    (sagittarius vm)
	    (sagittarius vm debug))

(include "smatch.scm")

;; same variables
;; TODO move this somewhere in C level
;; so that both Scheme and C can share the value.
(define-constant LEXICAL 0)		; the same as compiler.scm
(define-constant PATTERN 2)		; not LEXICAL nor SYNTAX
(define-constant BOUNDARY 3)

(define *root-env* (vector (find-library 'user #f) '() #f #f #f))
(define current-usage-env (make-core-parameter *root-env*))
(define current-macro-env (make-core-parameter *root-env*))
(define current-transformer-env (make-core-parameter '()))
(define (lookup-transformer-env o)
  (cond ((identifier? o)
	 (cond ((assq (id-name o) (current-transformer-env)) =>
		(lambda (r)
		  (and (pair? (cdr r)) (eq? (id-library o) (cadr r)) (cddr r))))
	       (else #f)))
	((symbol? o)
	 (cond ((assq o (current-transformer-env)) =>
		(lambda (r)
		  (and (not (pair? (cdr r)))
		       (cdr r))))
	       (else #f)))))
(define (add-to-transformer-env! o n)
  (let ((cte (current-transformer-env)))
    (if (identifier? o)
	(current-transformer-env (acons (id-name o)
					(cons (id-library o) n)
					cte))
	(current-transformer-env (acons o n cte)))
    n))

(define current-identity (make-core-parameter #f))
(define (generate-identity) (gensym "id."))

;;; identifier
;; we emulate current subr here, so it's rather ugly.
(define (%make-identifier name envs maybe-library pending?)
  (unless (or (symbol? name) (identifier? name))
    (assertion-violation 'make-identifier "symbol or identifier is required"
			 name))
  (let ((n (if (identifier? name) (id-name name) name))
	(lib (if (library? maybe-library)
		 maybe-library
		 (find-library maybe-library #f)))
	(new-env (cond ((null? envs) '())
		       ((identifier? name) (cons envs (id-envs name)))
		       (else (list envs))))
	(identity (cond ((null? envs) #f)
			((identifier? name)
			 (cons (current-identity) (id-identity name)))
			(else (cons (current-identity) #f)))))
    (make-raw-identifier n new-env identity lib pending?)))
(define (make-identifier name envs maybe-library)
  (%make-identifier name envs maybe-library #f))
(define (make-pending-identifier name envs maybe-library)
  (%make-identifier name envs maybe-library #t))

;; This will be inlined since these are not exported.
(define (p1env-library p1env) (vector-ref p1env 0))
(define (p1env-frames p1env) (vector-ref p1env 1))

;; free-identifier=?
;; this needs to be here since it requires both usage and macro env
(define (free-identifier=? id1 id2)
  #|
  (define (compare id1 id2)
    (define uenv (current-usage-env))
    (if (and uenv (eq? (id-name id1) (id-name id2)))
	(let ((v1 (p1env-lookup uenv id1 LEXICAL))
	      (v2 (p1env-lookup uenv id2 LEXICAL)))
	  (if (and (identifier? v1) (identifier? v2))
	      (let ((g1 (find-binding (id-library id1) (id-name id1) #f))
		    (g2 (find-binding (id-library id2) (id-name id2) #f)))
		(eq? g1 g2))
	      (eq? v1 v2)))
	(let ((g1 (find-binding (id-library id1) (id-name id1) #f))
	      (g2 (find-binding (id-library id2) (id-name id2) #f)))
	  (and g1 g2 (eq? g1 g2)))))
  (and (or (identifier? id1)
	   (assertion-violation 'free-identifier=? "identifier required" id1))
       (or (identifier? id2)
	   (assertion-violation 'free-identifier=? "identifier required" id2))
       (compare id1 id2))
  |#
  ;; above works but super slow
  ;; (aprox twice slower than the one implemented in C)
  ;; NB: yet still slower than it used (about twice)
  (vm-free-identifier=? id1 id2 (current-usage-env))
  )

;; implemented in C (see vmlib.stub) and exported from here.
;; (define (bound-identifier=? id1 id2)
;;   (define (compare id1 id2)
;;     (define identity1 (id-identity id1))
;;     (define identity2 (id-identity id2))
;;     (cond ((eq? identity1 identity2))
;; 	  ((or (not identity1) (not identity2)) #f)
;; 	  (else (let loop ((l1 identity1) (l2 identity2))
;; 		  (if (and (pair? l1) (pair? l2))
;; 		      (and (eq? (car l1) (car l2))
;; 			   (loop (cdr l1) (cdr l2)))
;; 		      (eq? l1 l2))))))
;;   (and (or (identifier? id1)
;; 	   (assertion-violation 'bound-identifier=? "identifier required" id1))
;;        (or (identifier? id2)
;; 	   (assertion-violation 'bound-identifier=? "identifier required" id2))
;;        (eq? (id-name id1) (id-name id2))
;;        (compare id1 id2)))

(define .vars (make-identifier '.vars '() '(core macro)))

;; in case of (rename (rnrs) (_ __)) or so...
;; _ and ... are defined in (core) library
(define .bar      (make-identifier '_ '() '(core)))
(define .ellipsis (make-identifier '... '() '(core)))

(define (literal-match? pat lites)
  (define (cmp pred pat lites)
    (let loop ((lites lites))
      (if (null? lites)
	  #f
	  (or (pred pat (car lites))
	      (loop (cdr lites))))))
  (if (identifier? pat)
      ;; literal comparison must be done in sense of
      ;; bound-identifier=?
      (cmp bound-identifier=? pat lites)
      (cmp (lambda (pat lite) (eq? pat (id-name lite))) pat lites)))

(define (bar? expr)
  (or (and (identifier? expr)
	   (free-identifier=? expr .bar))
      (and (variable? expr)
	   (identifier? (p1env-lookup (current-macro-env) expr LEXICAL))
	   (eq? expr '_))))

(define (ellipsis? expr)
  (or (and (identifier? expr)
	   (free-identifier=? expr .ellipsis))
      (and (variable? expr)
	   (identifier? (p1env-lookup (current-macro-env) expr LEXICAL))
	   (eq? expr '...))))

(define (ellipsis-pair? form)
  (and (pair? form)
       (pair? (cdr form))
       (ellipsis? (cadr form))))

(define (ellipsis-splicing-pair? form)
  (and (pair? form)
       (pair? (cdr form))
       (ellipsis? (cadr form))
       (pair? (cddr form))
       (ellipsis? (caddr form))))

(define (ellipsis-quote? form)
  (and (pair? form)
       (ellipsis? (car form))
       (pair? (cdr form))
       (null? (cddr form))))

(define (check-pattern pat lites)

  (define (check-duplicate-variable pat lites)
    (let loop ((lst pat) (pool '()))
      (cond ((pair? lst)
             (loop (cdr lst)
                   (loop (car lst) pool)))
            ((ellipsis? lst) pool)
            ((bar? lst) pool)
            ((variable?  lst)
             (if (literal-match? lst lites)
                 pool
                 (if (memq lst pool)
                     (syntax-violation "syntax pattern"
				       "duplicate pattern variables"
				       (unwrap-syntax pat)
				       (unwrap-syntax lst))
                     (cons lst pool))))
            ((vector? lst)
             (loop (vector->list lst) pool))
            (else pool))))

  (define (check-misplaced-ellipsis pat lites)
    (let loop ((lst pat))
      (cond ((ellipsis? lst)
             (syntax-violation "syntax pattern" "improper use of ellipsis"
			       (unwrap-syntax pat)))
            ((ellipsis-pair? lst)
             (and (variable? (car lst))
                  (literal-match? (car lst) lites)
                  (syntax-violation "syntax pattern"
				    "ellipsis following literal"
				    (unwrap-syntax pat) (unwrap-syntax lst)))
             (let loop2 ((lst (cddr lst)))
               (and (pair? lst)
                    (if (ellipsis? (car lst))
                        (assertion-violation "syntax pattern"
					     "ambiguous use of ellipsis" pat)
                        (loop2 (cdr lst))))))
            ((pair? lst)
             (or (loop (car lst)) (loop (cdr lst))))
            ((vector? lst)
             (loop (vector->list lst)))
            (else #f))))

  (check-misplaced-ellipsis pat lites)
  (check-duplicate-variable pat lites))

;; for global call.
(define .match-syntax-case (make-identifier 'match-syntax-case '()
					    '(core macro)))
(define .list (make-identifier 'list '() '(core macro)))
(define .lambda (make-identifier 'lambda '() '(core macro)))

;; exclude '...
(define (collect-unique-ids expr)
  (let loop ((lst expr) (ans '()) (seen '()))
    (cond ((memq lst seen) ans)
	  ((pair? lst)
	   (let ((seen (cons lst seen)))
             (loop (cdr lst)
                   (loop (car lst) ans seen)
		   seen)))
          ((ellipsis? lst) ans)
          ((variable? lst)
           (if (memq lst ans) ans (cons lst ans)))
          ((vector? lst)
	   (let ((seen (cons lst seen)))
             (loop (vector->list lst) ans seen)))
          (else ans))))

(define (collect-vars-ranks pat lites depth ranks)
  (cond ((bar? pat) ranks)
        ((variable? pat)
         (if (literal-match? pat lites)
             ranks
             (acons pat depth ranks)))
        ((ellipsis-pair? pat)
         (collect-vars-ranks (cddr pat) lites depth
                             (if (variable? (car pat))
                                 (acons (car pat) (+ depth 1) ranks)
                                 (collect-vars-ranks (car pat) lites
                                                     (+ depth 1) ranks))))
        ((pair? pat)
         (collect-vars-ranks (cdr pat) lites depth
                             (collect-vars-ranks (car pat)
                                                 lites depth ranks)))
        ((vector? pat)
         (collect-vars-ranks (vector->list pat) lites depth ranks))
        (else ranks)))

(define syntax-quote. (make-identifier 'syntax-quote '()
				       '(sagittarius compiler)))

(define (syntax-case-source-info r expr)
  (source-info*! r (source-info expr) '(expander . syntax-case)))


(define *cyclic-mark* (make-identifier '*cycle* '() '(core macro)))
(define (make-cyclic-mark l) (vector *cyclic-mark* l #f))
(define (cycle-mark? v)
  (and (vector? v)
       (= (vector-length v) 3)
       (eq? (vector-ref v 0) *cyclic-mark*)))
(define (cycle-label v) (vector-ref v 1))
(define (cycle-value v) (vector-ref v 2))
(define (cycle-value-set! v o) (vector-set! v 2 o))
(define (cycle-marked-obj mark seen)
  (and (cycle-mark? mark)
       (cond ((assq (cycle-label mark) seen) =>
	      (lambda (slot) (cycle-value (cdr slot))))
	     (else #f))))
(define (update-cycle-mark! mark lst seen)
  (cycle-value-set! mark lst)
  (let loop ((lst lst))
    (when (pair? lst)
      (cond ((cycle-marked-obj (car lst) seen) =>
	     (lambda (v) (set-car! lst v) (loop (cdr lst))))
	    ;; if we set cdr, then it's done
	    ((cycle-marked-obj (cdr lst) seen) => (lambda (v) (set-cdr! lst v)))
	    (else (loop (cdr lst))))))
  lst)

(define (update-vector-cycle-mark! mark vec seen)
  (define len (vector-length vec))
  (cycle-value-set! mark vec)
  (do ((i 0 (+ i 1)))
      ((= i len) vec)
    (let ((e (vector-ref vec i)))
      (cond ((cycle-marked-obj e seen) => (lambda (v) (vector-set! vec i v)))))))

(define (rewrite-vector rec form seen)
  (define len (vector-length form))
  (define mark (make-cyclic-mark form))

  (let ((seen (acons form mark seen)))
    (let loop ((i 0) (vec #f))
      (if (= i len)
	  (or (and vec (update-vector-cycle-mark! mark vec seen)) form)
	  (let ((e (rec (vector-ref form i) seen)))
	    (if (eq? e (vector-ref form i))
		(loop (+ i 1) vec)
		(let ((v (or vec (vector-copy form))))
		  (vector-set! v i e)
		  (loop (+ i 1) v))))))))

(define (rewrite-pair rec lst seen)
  (let* ((mark (make-cyclic-mark lst))
	 (seen (acons lst mark seen)))
    (let ((a (rec (car lst) seen))
	  (d (rec (cdr lst) seen)))
      (if (and (eq? (car lst) a) (eq? (cdr lst) d))
	  lst
	  (let ((r (cons a d)))
	    (update-cycle-mark! mark r seen)
	    (syntax-case-source-info r lst))))))

(define (rewrite-form form seen env library
		      make-identifier
		      handle-identifier)
  (define (seen-or-gen id env library)
    (or (hashtable-ref seen id #f)
	(let ((new-id (make-identifier id env library)))
	  (hashtable-set! seen id new-id)
	  new-id)))
  (let loop ((expr form) (seen '()))
    (cond ((assq expr seen) => cdr)
	  ((pair? expr) (rewrite-pair loop expr seen))
	  ((vector? expr) (rewrite-vector loop expr seen))
	  ((and (identifier? expr) (handle-identifier expr))
	   (seen-or-gen expr env (id-library expr)))
	  ((symbol? expr) (seen-or-gen expr env library))
	  (else expr))))

(define (pattern-identifier? id p1env)
  (number? (p1env-lookup p1env id PATTERN)))

;; syntax-case compiler
(define compile-syntax-case
  (lambda (exp-name expr literals clauses library env mac-env make-p1env)

    (define (extend-env newframe env) (acons PATTERN newframe env))
    
    (define mac-save (current-macro-env))
    (define use-save (current-usage-env))

    (define (rewrite-literals oexpr p1env)
      (define seen (make-eq-hashtable))
      (rewrite-form oexpr seen env library
		    ;; at this stage, symbol must be converted to
		    ;; the same meaning of identifier
		    (lambda (name env library)
		      (make-identifier name (if (symbol? name) '() env)
				       library))
		    ;; if it's identifier then don't
		    (lambda (id) #f)))
    ;; set both macro and usage env so that free-identifier=? can
    ;; use this env for compilation
    (current-macro-env mac-env)
    (current-usage-env mac-env)
    (let ((lites (rewrite-literals literals mac-env)))
      (define (rewrite oexpr patvars p1env)
	(define seen (make-eq-hashtable))
	;; can be for-each but it won't be inlined so this is faster.
	(let loop ((patvars patvars))
	  (unless (null? patvars)
	    (let ((pvar (car patvars)))
	      (hashtable-set! seen (car pvar) (cdr pvar))
	      (loop (cdr patvars)))))
	(for-each (lambda (literal lite)
		    (hashtable-set! seen literal lite)) literals lites)
	(rewrite-form oexpr seen env library
		      ;; at this stage, symbol must be converted to
		      ;; the same meaning of identifier
		      (lambda (name env library)
			(make-identifier name (if (symbol? name) '() env)
					 library))
		      (lambda (id) 
			(and (not (pending-identifier? id))
			     (not (pattern-identifier? id p1env))))))
      (define (parse-pattern pattern)
	(define (gen-patvar p)
	  (let ((p (car p)))
	    ;; preserve local variable to detect the following:
	    ;; (let-syntax ((_ (syntax-rules ())))
	    ;;   (let-syntax ((foo (syntax-rules () ((_ _) _))))
	    ;;     (foo 'bar)))
	    (cons p (make-identifier p env library))))
	(check-pattern pattern lites)
	(let* ((ranks (collect-vars-ranks pattern lites 0 '()))
	       (pvars (map gen-patvar ranks)))
	  (values (rewrite pattern pvars mac-env)
		  (make-p1env mac-env 
			      (extend-env (rewrite ranks pvars mac-env) env))
		  pvars)))

      (or (and (list? lites) (for-all identifier? lites))
	  (syntax-violation 'syntax-case "invalid literals" expr literals))
      (or (unique-id-list? lites)
	  (syntax-violation 'syntax-case "duplicate literals" expr literals))
      (and (literal-match? .bar lites)
	   (syntax-violation 'syntax-case "_ in literals" expr literals))
      (and (literal-match? .ellipsis lites)
	   (syntax-violation 'syntax-case "... in literals" expr literals))

      (let ((r (map (lambda (clause)
		      (smatch clause
			((p expr)
			 (receive (pattern env patvars) (parse-pattern p)
			   (cons `(,.list (,syntax-quote. ,pattern)
					  #f
					  (,.lambda (,.vars)
					    ,(rewrite expr patvars env)))
				 env)))
			((p fender expr)
			 (receive (pattern env patvars) (parse-pattern p)
			   (cons `(,.list (,syntax-quote. ,pattern)
					  (,.lambda (,.vars)
					    ,(rewrite fender patvars env))
					  (,.lambda (,.vars)
					    ,(rewrite expr patvars env)))
				 env)))))
		    clauses)))
	;; restore it
	(current-macro-env mac-save)
	(current-usage-env use-save)
	(values .match-syntax-case
		lites
		(p1env-lookup mac-env .vars LEXICAL BOUNDARY)
		r)))))

(define (count-pair lst)
  (let loop ((lst lst) (n 0) (seen '()))
    (cond ((memq lst seen) n)
	  ((pair? lst) (loop (cdr lst) (+ n 1) (cons lst seen)))
	  (else n))))

(define (match-ellipsis? expr pat lites seen)
  (or (null? expr)
      (and (pair? expr)
           (match-pattern? (car expr) (car pat) lites seen)
           (match-ellipsis? (cdr expr) pat lites seen))))

(define (match-ellipsis-n? expr pat n lites seen)
  (or (= n 0)
      (and (pair? expr)
           (match-pattern? (car expr) (car pat) lites seen)
           (match-ellipsis-n? (cdr expr) pat (- n 1) lites seen))))

(define (match-pattern? expr pat lites seen)
  (define (compare pat expr)
    (define (ensure-id id env)
      (if (identifier? id)
	  id
	  (make-identifier id (p1env-frames env) (p1env-library env))))
    ;; pat is pattern variable so it's always identifier
    ;; but in case...
    (let ((p-id (ensure-id pat  (current-macro-env)))
	  (e-id (ensure-id expr (current-usage-env))))
      (free-identifier=? p-id e-id)))
  ;; if we already see this expression, then previous must already be matched
  ;; i guess...
  ;; This causes (p ...) matches with a variable, so we need better detection
  (cond #;((memq expr seen) #t)
	((bar? pat) #t)
        ((variable? pat)
         (cond ((literal-match? pat lites)
                (and (variable? expr)
                     (compare pat expr)))
               (else #t)))
        ((ellipsis-pair? pat)
	 (let ((seen (cons expr seen)))
           (if (and (null? (cddr pat)) (list? expr))
               (or (variable? (car pat))
                   (match-ellipsis? expr pat lites seen))
               (let ((n (- (count-pair expr) (count-pair (cddr pat)))))
		 (if (= n 0)
                     (match-pattern? expr (cddr pat) lites seen)
                     (and (> n 0)
                          (match-ellipsis-n? expr pat n lites seen)
                          (match-pattern? (list-tail expr n) (cddr pat)
                                          lites seen)))))))
        ((pair? pat)
	 (let ((seen (cons expr seen)))
           (and (pair? expr)
		(match-pattern? (car expr) (car pat) lites seen)
		(match-pattern? (cdr expr) (cdr pat) lites seen))))
        ((vector? pat)
         (and (vector? expr)
              (match-pattern? (vector->list expr) (vector->list pat)
			      lites seen)))
        (else (equal? pat expr))))

(define (union-vars vars evars)
  (if (null? evars)
      vars
      (union-vars (bind-var! (caar evars) (reverse (cdar evars)) vars)
                  (cdr evars))))

(define (bind-var! pat expr vars)
  (cond ((bar? pat) vars)
        (else
         (let ((slot (assq pat vars)))
           (if slot
               (begin (set-cdr! slot (cons expr (cdr slot))) vars)
               (acons pat (list expr) vars))))))

(define (bind-null-ellipsis pat lites vars)
  (let loop ((lst (collect-unique-ids (car pat))) (vars vars))
    (if (null? lst)
        vars
        (loop (cdr lst)
              (if (memq (car lst) lites)
                  vars
                  (bind-var! (car lst) '() vars))))))

(define (bind-ellipsis expr pat lites vars evars)
  (if (null? expr)
      (if (null? evars)
          (bind-null-ellipsis pat lites vars)
          (union-vars vars evars))
      (bind-ellipsis (cdr expr) pat lites vars
                     (bind-pattern (car expr) (car pat) lites evars))))

(define (bind-ellipsis-n expr pat lites n vars evars)
  (if (= n 0)
      (if (null? evars)
          (bind-null-ellipsis pat lites vars)
          (union-vars vars evars))
      (bind-ellipsis-n (cdr expr) pat lites (- n 1) vars
                       (bind-pattern (car expr) (car pat) lites evars))))

(define (bind-pattern expr pat lites vars)
  (cond ((variable? pat)
         (if (literal-match? pat lites)
             vars
             (bind-var! pat expr vars)))
        ((ellipsis-pair? pat)
         (if (and (null? (cddr pat)) (list? expr))
             (if (variable? (car pat))
                 (bind-var! (car pat) expr vars)
                 (bind-ellipsis expr pat lites vars '()))
             (let ((n (- (count-pair expr) (count-pair (cddr pat)))))
               (bind-pattern (list-tail expr n) (cddr pat) lites
                             (if (and (= n 0) (variable? (car pat)))
                                 (bind-var! (car pat) '() vars)
                                 (bind-ellipsis-n expr pat lites n
                                                  vars '()))))))
        ((pair? pat)
	 (bind-pattern (cdr expr) (cdr pat) lites
		       (bind-pattern (car expr) (car pat) lites vars)))
        ((vector? pat)
         (bind-pattern (vector->list expr) (vector->list pat) lites vars))
        (else vars)))


(define (no-matching-pattern who form patterns)
  (raise (apply condition
		(make-syntax-violation form #f)
		(or (and who (make-who-condition who))
		    (make-who-condition 'syntax-case))
		(make-message-condition "Input form doesn't match any pattern")
		(map make-syntax-pattern-condition patterns))))	  

(define (match-syntax-case patvars literals form . olst)
  (define (match form pat)
    (and (match-pattern? form pat literals '())
	 (bind-pattern form pat literals '())))

  ;; we need to local variable unique so that it won't be global.
  (let loop ((lst olst))
    (if (null? lst)
	(no-matching-pattern (and (pair? form) (car form))
			     (unwrap-syntax form)
			     (map car olst))
	(let ((clause (car lst)))
	  (let ((pat (car clause))
		(fender (cadr clause))
		(expr (caddr clause)))
	    (let ((vars (match form pat)))
	      (if (and vars
		       (or (not fender)
			   (apply fender (list (append vars patvars)))))
		  (apply expr (list (append vars patvars)))
		  (loop (cdr lst)))))))))

;; compile (syntax ...)
(define .expand-syntax (make-identifier 'expand-syntax '() '(core macro)))
(define (collect-rename-ids template ranks)
  (let ((ids (collect-unique-ids template)))
    (let loop ((lst ids))
      (if (null? lst)
          lst
          (if (assq (car lst) ranks)
              (loop (cdr lst))
              (cons (car lst) (loop (cdr lst))))))))

(define (parse-ellipsis-splicing form)
  (let loop ((len 2) (tail (cdddr form)))
    (cond ((and (pair? tail) (ellipsis? (car tail)))
           (loop (+ len 1) (cdr tail)))
          (else
           (values (list-head form len) tail len)))))

(define (syntax-template-violation message form tmpl)
  (raise (condition
	  (make-syntax-violation tmpl form)
	  (make-who-condition "syntax template")
	  (make-message-condition message))))

(define (check-template tmpl ranks)
  (define (control-patvar-exists? tmpl depth)
    (let loop ((lst tmpl) (depth depth))
      (cond ((variable? lst)
	     (>= (rank-of lst ranks) depth))
	    ((ellipsis-quote? lst)
	     (exists (lambda (id) (>= (rank-of id ranks) depth))
		     (collect-unique-ids lst)))
	    ((ellipsis-splicing-pair? lst)
	     (receive (body tail len) (parse-ellipsis-splicing lst)
	       (or (loop body (+ depth 1))
		   (and (loop body 1)
			(loop tail depth)))))
	    ((ellipsis-pair? lst)
	     (or (loop (car lst) (+ depth 1))
		 (and (loop (car lst) 1)
		      (loop (cddr lst) depth))))
	    ((pair? lst)
	     (or (loop (car lst) depth)
		 (loop (cdr lst) depth)))
	    ((vector? lst)
	     (loop (vector->list lst) depth))
	    (else #f))))

  (define (check-escaped lst depth)
    (let loop ((lst lst))
      (cond ((variable? lst)
	     (and (< 0 (rank-of lst ranks) depth)
		  (syntax-template-violation
		   "too few ellipsis following subtemplate"
		   (unwrap-syntax lst)
		   tmpl)))
	    ((pair? lst)
	     (loop (car lst))
	     (loop (cdr lst)))
	    ((vector? lst)
	     (loop (vector->list lst))))))

  (if (and (= (length tmpl) 2) (ellipsis? (car tmpl)))
      (check-escaped (cadr tmpl) 0)
      (let loop ((lst tmpl) (depth 0) (seen '()))
	(cond ((memq lst seen))
	      ((variable? lst)
	       (and (ellipsis? lst)
		    (syntax-template-violation "misplaced ellipsis"
					       tmpl tmpl))
	       (and (> (rank-of lst ranks) depth)
		    (syntax-template-violation
		     "too few ellipsis following subtemplate"
		     (unwrap-syntax lst)
		     tmpl)))
	      ((ellipsis-quote? lst)
	       (check-escaped (cadr lst) depth))
	      ((ellipsis-splicing-pair? lst)
	       (receive (body tail len) (parse-ellipsis-splicing lst)
		 (and (= depth 0)
		      (or (control-patvar-exists? (car lst) len)
			  (syntax-template-violation
			   "missing pattern variable that used in same level as in pattern" (unwrap-syntax lst) tmpl)))
		 (let ((seen (cons lst seen)))
		   (loop body (+ depth 1) seen)
		   (loop tail depth seen))))
	      ((ellipsis-pair? lst)
	       (let ((seen (cons lst seen)))
		 (cond ((variable? (car lst))
			(let ((rank (rank-of (car lst) ranks)))
			  (cond ((< rank 0)
				 (syntax-template-violation
				  "misplaced ellipsis following literal"
				  (unwrap-syntax (car lst)) tmpl))
				((> rank (+ depth 1))
				 (syntax-template-violation
				  "too few ellipsis following subtemplate"
				  (unwrap-syntax (car lst)) tmpl))
				(else
				 (loop (cddr lst) depth seen)))))
		       ((pair? (car lst))
			(and (= depth 0)
			     (or (control-patvar-exists? (car lst) (+ depth 1))
				 (syntax-template-violation
				  "missing pattern variable that used in same level as in pattern" (car lst) tmpl)))
			(loop (car lst) (+ depth 1) seen)
			(loop (cddr lst) depth seen))
		       ((null? (car lst))
			(syntax-template-violation
			 "misplaced ellipsis following empty list" #f tmpl))
		       (else
			(syntax-template-violation
			 "misplaced ellipsis following literal" (car lst) tmpl)))))
	      ((pair? lst)
	       (let ((seen (cons lst seen)))
		 (loop (car lst) depth seen)
		 (loop (cdr lst) depth seen)))
	      ((vector? lst)
	       (let ((seen (cons lst seen)))
		 (loop (vector->list lst) depth seen)))))))

;; exp-name: current expression name for debug
;; tmpl:     template (if it's in syntax-case, this must be wrapped)
;; env:      p1env only frame
;; mac-env:  whole p1env.
;;
;; template is wrapped by syntax-case so that we can retrieve pattern
;; variables from mac-env.
;; .var is special hidden variable used only in macro expansion phase.
;; it contains all lexical variables for fender and expander. 
;; see compile-syntax-case.
(define (compile-syntax exp-name tmpl env mac-env)
  ;; need to keep which library the symbols are defined.
  (define (rewrite tmpl ranks)
    (rewrite-form tmpl 
		  (make-eq-hashtable) 
		  env
		  (p1env-library mac-env)
		  (lambda (name env library)
		    (make-identifier name (if (symbol? name) '() env)
				     library))
		  (lambda (id)
		    (and (or (not (pending-identifier? id))
			     ;; FIXME 
			     (not (identifier?
				   (p1env-lookup mac-env id LEXICAL))))
			 ;; 'ranks' contains pattern variables so 
			 ;; not need for this
			 ;; (not (pattern-identifier? id mac-env))
			 (not (assoc id ranks bound-identifier=?))))))

  (let* ((ids (collect-unique-ids tmpl))
	 (ranks (filter-map (lambda (id)
			      (let ((p (p1env-lookup mac-env id PATTERN)))
				(and (number? p)
				     (cons id p))))
			    ids))
	 (template (rewrite tmpl ranks)))
    ;; later
    (check-template template ranks)
    (let ((patvar (let ((v (p1env-lookup mac-env .vars LEXICAL BOUNDARY)))
		    ;; if .vars is identifier, then it must be toplevel
		    ;; so not a pattarn variable.
		    (if (identifier? v)
			'()
			.vars))))
      (if (variable? template)
	  (if (null? ranks)
	      `(,.expand-syntax ,patvar
				(,syntax-quote. ,template)
				())
	      `(,.expand-syntax ,patvar
				(,syntax-quote. ,template)
				(,syntax-quote. ,(list (cons template 0)))))
	  `(,.expand-syntax ,patvar 
			    (,syntax-quote. ,template)
			    (,syntax-quote. ,ranks))))))

(define expand-syntax
  (lambda (vars template ranks)
    (define use-env (current-usage-env))
    (define mac-env (current-macro-env))

    (define (contain-identifier? lst)
      (define seen (make-eq-hashtable))
      (let loop ((lst lst))
	(cond ((hashtable-ref seen lst #f) #f)
	      ((pair? lst)
	       (hashtable-set! seen lst #t)
	       (or (null? (car lst)) (loop (car lst)) (loop (cdr lst))))
	      ((vector? lst)
	       (hashtable-set! seen lst #t)
	       (let loop2 ((i (- (vector-length lst) 1)))
		 (and (>= i 0)
		      (or (loop (vector-ref lst i))
			  (loop2 (- i 1))))))
	      (else (identifier? lst)))))

    ;; wrap the given symbol with current usage env frame.
    (define (wrap-symbol sym)
      (define (finish new) (add-to-transformer-env! sym new))
      (let ((use-lib (p1env-library use-env)))
	(finish (make-identifier sym '() use-lib))))

    (define (partial-identifier olst)
      (define (check-binding name env library)
	(and-let* ((id (p1env-lookup env name LEXICAL))
		   ( (identifier? id)) )
	  (find-binding library (id-name id) #f)))
      (let loop ((lst olst) (seen '()))
	(cond ((assq lst seen) => cdr)
	      ((contain-identifier? lst)
	       (cond ((pair? lst) (rewrite-pair loop lst seen))
		     ((vector? lst) (rewrite-vector loop lst seen))
		     (else lst)))
	      ((null? lst) '())
	      ((symbol? lst)
	       (cond ((lookup-transformer-env lst))
		     (else (wrap-symbol lst))))
	      ((vector? lst) (rewrite-vector loop lst seen))
	      ((pair? lst) (rewrite-pair loop lst seen))
	      (else lst))))

    (define (rewrite template)
      (rewrite-form template
		    (make-eq-hashtable)
		    (p1env-frames mac-env)
		    (p1env-library mac-env)
		    (lambda (name env lib)
		      (cond ((lookup-transformer-env name))
			    (else
			     ;; fake the identifier creation
			     ;; TODO not sure if this is actually correct
			     (let* ((env (if (null? env) `((,LEXICAL)) env))
				    (id (make-pending-identifier name env lib)))
			       (add-to-transformer-env! name id)))))
		    ;; preserve pattern variables
		    ;; all template variables must be renamed here
		    (lambda (id)
		      ;; 'ranks' contains pattern variables
		      ;; so not need to call pattern-identifier?
		      (not (assoc id ranks bound-identifier=?)))))
    (if (null? template)
	'()
	(let* ((templ (rewrite template))
	       (form (transcribe-template templ ranks vars)))
	  (cond ((null? form) '())
		;; this causes
		;; (syntax-case '(a b c) () ((a b c) (list #'a #'b #'c)))
		;; results (#<id a> #<id b> #<id c>) but I don't know
		;; how to deal with it...
		((eq? use-env mac-env) form) ; we don't wrap toplevel form
		((identifier? form) form)
		((symbol? form)
		 (cond ((lookup-transformer-env form))
		       (else (wrap-symbol form))))
		(else (partial-identifier form)))))))

(define (rank-of name ranks)
  (define (find-rank ranks)
    (let loop ((ranks ranks))
      (if (null? ranks)
	  -1
	  (let ((slot (car ranks)))
	    (if (bound-identifier=? name (car slot))
		(cdr slot)
		(loop (cdr ranks)))))))
  (find-rank ranks))

(define (subform-of name vars) (cdr (assq name vars)))

(define collect-ellipsis-vars
  (lambda (tmpl ranks depth vars)
    (let ((ids (collect-unique-ids tmpl)))
      ;; vars may contains the same pattern identifier more than once.
      ;; in that case, we need to take only the top most one like usual
      ;; environment lookup (shadowing).
      (let loop ((vars vars) (appeared '()) (r '()))
	(if (null? vars) 
	    (reverse! r)
	    (let* ((slot (car vars))
		   (p    (car slot)))
	      (if (and (member p ids bound-identifier=?)
		       (not (member p appeared bound-identifier=?)))
		  (let ((rank (cdr (assoc p ranks bound-identifier=?))))
		    (loop (cdr vars)
			  (cons p appeared)
			  (cons (cond ((< rank depth) slot)
				      ((null? (cdr slot)) slot)
				      (else (cons (car slot) (cadr slot))))
				r)))
		  (loop (cdr vars) appeared r))))))))

(define contain-rank-moved-var?
  (lambda (tmpl ranks vars)

    (define (traverse-escaped lst depth)
      (let loop ((lst lst) (depth depth) (seen '()))
	(cond ((memq lst seen) #f)
	      ((variable? lst)
	       (< 0 (rank-of lst ranks) depth))
	      ((pair? lst)
	       (let ((seen (cons lst seen)))
		 (or (loop (car lst) depth seen)
		     (loop (cdr lst) depth seen))))
	      ((vector? lst)
	       (let ((seen (cons lst seen)))
		 (loop (vector->list lst) depth seen)))
	      (else #f))))

    (let loop ((lst tmpl) (depth 0) (seen '()))
      (cond ((memq lst seen) #f)
	    ((variable? lst)
             (< 0 (rank-of lst ranks) depth))
            ((ellipsis-quote? lst)
             (traverse-escaped (cadr lst) depth))
            ((ellipsis-splicing-pair? lst)
             (let-values (((body tail len) (parse-ellipsis-splicing lst)))
               (or (loop body (+ depth 1) seen)
                   (loop tail depth seen))))
            ((ellipsis-pair? lst)
	     (let ((seen (cons lst seen)))
               (or (loop (car lst) (+ depth 1) seen)
                   (loop (cddr lst) depth seen))))
            ((pair? lst)
	     (let ((seen (cons lst seen)))
               (or (loop (car lst) depth seen)
                   (loop (cdr lst) depth seen))))
            ((vector? lst)
	     (let ((seen (cons lst seen)))
               (loop (vector->list lst) depth seen)))
            (else #f)))))

(define adapt-to-rank-moved-vars
  (lambda (form ranks vars)
    (define (rewrite-template-ranks-vars tmpl ranks vars)
      (define moved-ranks (make-eq-hashtable))
      (define moved-vars (make-eq-hashtable))

      (define (make-infinite-list e)
	(let ((lst (list e)))
	  (set-cdr! lst lst)
	  lst))

      (define (revealed name depth)
	(cond ((< 0 (rank-of name ranks) depth)
	       (let ((renamed (copy-identifier (gensym) name)))
		 (or (hashtable-ref moved-ranks renamed #f)
		     (let loop ((i (- depth (rank-of name ranks)))
				(var (subform-of name vars)))
		       (cond ((> i 0)
			      (loop (- i 1) 
				    (list (make-infinite-list (car var)))))
			     (else
			      (hashtable-set! moved-ranks renamed depth)
			      (hashtable-set! moved-vars renamed var)))))
		 renamed))
	      ((assq name vars) name)
	      (else name)))

      (define (traverse-escaped lst depth)
	(let loop ((lst lst) (depth depth))
	  (cond ((variable? lst)
		 (revealed lst depth))
		((pair? lst)
		 (cons (loop (car lst) depth)
		       (loop (cdr lst) depth)))
		((vector? lst)
		 (list->vector (loop (vector->list lst) depth)))
		(else lst))))

      (define (rewrite tmpl)
	(let loop ((lst tmpl) (depth 0))
	  (cond ((variable? lst)
		 (revealed lst depth))
		((ellipsis-quote? lst)
		 (cons (car lst)
		       (traverse-escaped (cdr lst) depth)))
		((ellipsis-splicing-pair? lst)
		 (let-values (((body tail len) 
			       (parse-ellipsis-splicing lst)))
		   (append (loop body (+ depth 1))
			   (cons .ellipsis (loop tail depth)))))
		((ellipsis-pair? lst)
		 (cons (loop (car lst) (+ depth 1))
		       (cons .ellipsis (loop (cddr lst) depth))))
		((pair? lst)
		 (cons (loop (car lst) depth)
		       (loop (cdr lst) depth)))
		((vector? lst)
		 (list->vector (loop (vector->list lst) depth)))
		(else lst))))

      (let ((rewrited (rewrite tmpl)))
	(values rewrited
		(append ranks (hashtable->alist moved-ranks))
		(append vars (hashtable->alist moved-vars)))))

    (if (contain-rank-moved-var? form ranks vars)
        (rewrite-template-ranks-vars form ranks vars)
        (values form ranks vars))))

(define (consume-ellipsis-vars ranks depth vars)
  (let ((exhausted #f) (consumed #f))
    ;; consumed exhausted return
    ;; #t       #t    --> #f        error, different size of matched subform
    ;; #t       #f    --> remains   more variable to reveal
    ;; #f       #t    --> #t        all variable revealed
    ;; #f       #f    --> ()        no variable revealed
    (let ((remains
           (let loop ((lst vars))
             (cond ((null? lst) lst)
                   ((< (rank-of (caar lst) ranks) depth)
                    (cons (car lst) (loop (cdr lst))))
                   ((null? (cdar lst))
                    (loop (cdr lst)))
                   ((null? (cddar lst))
                    (set! exhausted #t)
                    (loop (cdr lst)))
                   (else
                    (or (circular-list? (cdar lst)) (set! consumed #t))
                    (acons (caar lst) (cddar lst) (loop (cdr lst))))))))
      (if consumed
          (and (not exhausted) remains)
          (or exhausted '())))))

(define transcribe-template
  (lambda (in-form in-ranks in-vars)
    (define (source-info! r t) (syntax-case-source-info r t))
    (let-values (((otmpl ranks vars)
		  (adapt-to-rank-moved-vars in-form in-ranks in-vars)))

      (define (expand-var tmpl vars)
	(cond ((assoc tmpl vars bound-identifier=?)
	       => (lambda (slot)
		    (cond ((null? (cdr slot)) '())
			  (else (cadr slot)))))
	      (else
	       (syntax-template-violation
		"subforms have different size of matched input (variable)"
		tmpl
		in-form))))
      (define (expand-ellipsis-var tmpl vars)
	(cond ((assoc tmpl vars bound-identifier=?)
	       => (lambda (slot)
		    (cond ((null? (cdr slot)) '())
			  (else (cadr slot)))))
	      (else
	       (syntax-template-violation
		"subforms have different size of matched input (ellipsis)"
		tmpl
		in-form))))

      (define (expand-ellipsis-template tmpl depth vars seen)
	(let loop ((expr '())
		   (remains (collect-ellipsis-vars tmpl ranks depth vars)))
	  (cond ((pair? remains)
		 (loop (cons (expand-template tmpl depth remains seen) expr)
		       (consume-ellipsis-vars ranks depth remains)))
		((null? remains) '())
		((eq? remains #t) (reverse expr))
		(else
		 (syntax-template-violation
		  "subforms have different size of matched input"
		  tmpl
		  in-form)))))

      (define (expand-escaped-template tmpl depth vars seen)
	(cond ((variable? tmpl)
	       (if (< (rank-of tmpl ranks) 0)
		   tmpl
		   (expand-var tmpl vars)))
	      ((pair? tmpl)
	       (source-info! 
		(cons (expand-escaped-template (car tmpl) depth vars seen)
		      (expand-escaped-template (cdr tmpl) depth vars seen))
		tmpl))
	      ((vector? tmpl)
	       (list->vector
		(expand-escaped-template (vector->list tmpl) depth vars seen)))
	      (else tmpl)))

      (define (expand-template tmpl depth vars seen)
	(define (handle-ellipsis-pair tmpl seen)
	  (cond ((variable? (car tmpl))
		 (let ((rank (rank-of (car tmpl) ranks)))
		   (if (= rank (+ depth 1))
		       (append (expand-ellipsis-var (car tmpl) vars)
			       (expand-template (cddr tmpl) depth vars seen)))))
		((pair? (car tmpl))
		 (append
		  (expand-ellipsis-template (car tmpl) (+ depth 1) vars seen)
		  (expand-template (cddr tmpl) depth vars seen)))))

	(cond ((assq tmpl seen) => cdr)
	      ((variable? tmpl)
	       (if (< (rank-of tmpl ranks) 0)
		   tmpl
		   (expand-var tmpl vars)))
	      ((ellipsis-quote? tmpl)
	       (expand-escaped-template (cadr tmpl) depth vars seen))
	      ((ellipsis-splicing-pair? tmpl)
	       (receive (body tail len) (parse-ellipsis-splicing tmpl)
		 (append
		  (apply append
			 (expand-ellipsis-template body (+ depth 1) vars seen))
		  (expand-template tail depth vars '()))))
	      ((ellipsis-pair? tmpl)
	       (let* ((mark (make-cyclic-mark tmpl))
		      (seen (acons tmpl mark seen)))
		 (let ((r (handle-ellipsis-pair tmpl seen)))
		   (update-cycle-mark! mark (source-info! r tmpl) seen))))
	      ((pair? tmpl)
	       (let* ((mark (make-cyclic-mark tmpl))
		      (seen (acons tmpl mark seen)))
		 (let ((r (cons (expand-template (car tmpl) depth vars seen)
				(expand-template (cdr tmpl) depth vars seen))))
		   (update-cycle-mark! mark (source-info! r tmpl) seen))))
	      ((vector? tmpl)
	       (let* ((mark (make-cyclic-mark tmpl))
		      (seen (acons tmpl mark seen)))
		 (let ((r (list->vector
			   (expand-template (vector->list tmpl)
					    depth vars seen))))
		   (update-vector-cycle-mark! mark r seen))))
	      (else tmpl)))

      (if (and (= (length otmpl) 2) (ellipsis? (car otmpl)))
	  (expand-escaped-template (cadr otmpl) 0 vars '())
	  (expand-template otmpl 0 vars '())))))

;; datum->syntax
(define datum->syntax
  (lambda (template-id datum)
    (define seen (make-eq-hashtable))
    ;; simply converts symbol to identifier.
    (define (rewrite expr)
      (rewrite-form expr
		    (make-eq-hashtable)
		    '() #f ;; dummy
		    (lambda (name env library)
		      (copy-identifier name template-id))
		    (lambda (id) #f)))
    (or (identifier? template-id)
	(assertion-violation 
	 'datum->syntax 
	 (format "expected identifier, but got ~s" template-id)))
    (rewrite datum)))

;; syntax->datum
(define (syntax->datum syntax)
  (unwrap-syntax syntax))

(define (generate-temporaries obj)
  (or (list? obj)
      (assertion-violation 'generate-temporaries
                           (format "expected list, but got ~s" obj)))
  (let ((lib (vm-current-library)))
    (let loop ((i 0) (obj obj) (r '()))
      (if (null? obj)
	  r
	  (loop (+ i 1)
		(cdr obj)
		;; hope it's unique enough
		(cons (make-identifier 
		       (string->symbol 
			(format "~a.~a'~a"
				(gensym "temp.")
				;; make it smaller
				(number->string (microsecond) 32)
				i))
		       '() lib)
		      r))))))

(define *variable-transformer-mark* (list 'variable-transformer))
(define (variable-transformer? o)
  (and (macro? o) (macro? (macro-data o))))
;; see blow
;; (define (variable-transformer? o)
;;   (and (macro? o)
;;        (eq? (macro-data o) *variable-transformer-mark*)))

;; make-macro-transformer
;; TODO use this when I'm done with cache refactoring.
;; NB: this version makes cache break. the (thunk) must not be
;;     called sint it may contain lifted lambda.
;; (define (make-macro-transformer name thunk env cb)
;;   (define transformer (thunk))
;;   (define (macro-transform me expr p1env data)
;;     (let ((usave (current-usage-env))
;; 	  (msave (current-macro-env))
;; 	  (isave (current-identity)))
;;       (current-usage-env p1env)
;;       (current-macro-env (macro-env me))
;;       (current-identity (generate-identity))
;;       (current-transformer-env '()) ;; we don't need the value.
;;       (dynamic-wind values
;; 	  (lambda () ((macro-data me) expr))
;; 	  (lambda ()
;; 	    (current-transformer-env '())
;; 	    (current-usage-env usave)
;; 	    (current-macro-env msave)
;; 	    (current-identity  isave)))))
;;   (if (macro? transformer)
;;       (make-macro name (macro-transformer transformer)
;; 		  *variable-transformer-mark* (macro-env transformer)
;; 		  cb)
;;       (make-macro name macro-transform transformer env cb)))

(define (macro-transform me expr p1env data)
  (let ((transformer data)
	(usave (current-usage-env))
	(msave (current-macro-env))
	(isave (current-identity)))
    (current-usage-env p1env)
    (current-macro-env (macro-env me))
    (current-identity (generate-identity))
    (current-transformer-env '()) ;; we don't need the value.
    (dynamic-wind values
	(lambda ()
	  (if (macro? transformer)
	      ((macro-transformer transformer) transformer
	       expr (macro-env me) (macro-data transformer))
	      (transformer expr)))
	(lambda ()
	  (current-transformer-env '())
	  (current-usage-env usave)
	  (current-macro-env msave)
	  (current-identity  isave)))))
(define (make-macro-transformer name thunk env cb)
  (make-macro name macro-transform (thunk) env cb))

(define (make-variable-transformer proc)
  (make-macro *variable-transformer-mark*
	      (lambda (m expr p1env data)
		(define (rewrite expr env)
		  (rewrite-form expr (make-eq-hashtable) (p1env-frames env)
				(p1env-library env) 
				;; the same as syntax-case
				(lambda (name env library)
				  (make-identifier name
						   (if (symbol? name) '() env)
						   library))
				(lambda (id) 
				  (and (not (pending-identifier? id))
				       (not (pattern-identifier? id p1env))))))
		;; use current usage env, issue 93
		(proc (rewrite expr (current-usage-env))))
	      '()
	      (current-macro-env)))

;; 'rename' procedure - we just return a resolved identifier
;; NB: when dict is #f, means caller wants to only rename but not store.
(define (er-rename symid p1env dict)
  (define (rename symid dict env lib)
    (let ((id (make-identifier symid env lib)))
      (when dict (hashtable-set! dict symid id))
      id))
  (unless (variable? symid)
    (assertion-violation 'er-macro-transformer
     (wrong-type-argument-message "a symbol or an identifier" symid 0)))
  (if (symbol? symid)
      (or (and dict (hashtable-ref dict symid #f))
	  (rename symid dict (p1env-frames p1env) (p1env-library p1env)))
      ;; the same renaming rule as syntax-case
      ;; TODO should we only rename when the `symid` is a pending identifier
      ;;      and locally bound the same as compile-syntax?
      ;;      the above is actually depending on non existing er-macro-expander
      ;;      specification. we can decide when the spec is there.
      (or (and (not (pending-identifier? symid))
	       (or (and dict (hashtable-ref dict symid #f))
		   (rename symid dict (p1env-frames p1env)
			   (id-library symid))))
	  symid)))

(define (er-source-info r expr)
  (source-info*! r (source-info expr) '(expander . er-transfomer)))
;; er-macro-transformer
(define (er-macro-transformer f)
  (lambda (expr)
    (let ((dict (make-eq-hashtable)))
      ;; renames given form not only symbol/identifier
      (define (rename s) 
	(define macro-env (current-macro-env))
	(define (rec form)
	  ;; We don't check cyclic list/vector, but if there's enough demand
	  (cond ((pair? form)
		 (let ((a (rec (car form)))
		       (d (rec (cdr form))))
		   (if (and (eq? a (car form)) (eq? d (cdr form)))
		       form
		       (er-source-info (cons a d) form))))
		((vector? form)
		 (let ((len (vector-length form)))
		   (let loop ((i 0) (vec #f))
		     (if (= i len)
			 (or vec form)
			 (let ((e (rec (vector-ref form i))))
			   (if (eq? e (vector-ref form i))
			       (loop (+ i 1) vec)
			       (let ((v (or vec (vector-copy form))))
				 (vector-set! v i e)
				 (loop (+ i 1) v))))))))
		((variable? form) (er-rename form macro-env dict))
		(else form)))
	(rec s))
      (define (compare a b)
	(define (ensure-id id env)
	  (if (identifier? id)
	      id
	      (er-rename id env #f)))
	(cond ((and (pair? a) (pair? b))
	       (and (compare (car a) (car b))
		    (compare (cdr a) (cdr b))))
	      ((and (variable? a) (variable? b))
	       (let ((env (current-usage-env)))
		 (free-identifier=? (ensure-id a env) (ensure-id b env))))
	      ((and (vector? a) (vector? b))
	       (let ((al (vector-length a))
		     (bl (vector-length b)))
		 (and (= al bl)
		      (let loop ((i 0))
			(or (= i al)
			    (and (compare (vector-ref a i) (vector-ref b i))
				 (loop (+ i 1))))))))
	      (else (equal? a b))))
      (propagate-source-info*!
       (f expr rename compare) expr '(expander . er-transfomer)))))
)
