;; -*- mode: scheme; coding: utf-8 -*-

;; basic strategy of renaming input expression.
;; 
;; the implementation of syntax-case depending on the behaviours of
;; free-identifier=? and bound-identifier=?. when we need to consider
;; what's bound to the target identifier, then we need to use
;; free-identifier=?. Otherwise bound-identifier=? to simply compare
;; if the identifier is created in the same macro expansion process.
;; 
;; renaming identifiers or symbols are mostly straightforward. we
;; simply rename given symbols or identifiers except if the given
;; identifier is pending identifier or pattern variable. pending
;; identifier is a type of identifier which will be create during
;; syntax (#') compilation. this identifier may or may not be
;; renamed (the name of the identifier itself will be changed) by
;; the compiler to make macro somewhat hygienic. this renaming process
;; depends on the identity (in sense of eq?) of the identifier. so we
;; can't rename it twice unless it's absolutely needed.
;; pattern variables need to be treated a bit specially. they are
;; basically not renamed once it's created. so whenever renaming
;; process is run it needs to be considered. however the renamed
;; identifier of pattern variable does not have any mark to determine
;; whether or not it's pattern identifier. so we need to look up
;; compiler environment. comparing pattern identifier must always
;; be done by in sense of bound-identifier=?. 
;; matching pattern variable and literals must always be done by 
;; in sense of bound-identifier=?. consider the following case:
;;
;;   (define-syntax foo
;;     (syntax-rules ()
;;       ((_ a b)
;;        (let-syntax ((bar (syntax-rules (a)
;;                            ((_ b) 'ok)
;;                            ((_ d) 'ng))))
;;          (bar d)))
;;       ((_ x ...)
;;        (foo x ... t))))
;; 
;; the literal 'a' (actual value is 't') is generated by the macro 
;; expansion and the 'b' of syntax pattern '(_ b)' (actual value is
;; '(_ t)') is created in different macro expansion process. in this
;; case if we compare them in sense of free-identifier=? then it
;; return #t but that's not correct. comparing pattern and literals
;; with bound-identifier=? should always succeed since we preserve
;; renamed pattern variables.

;; same variables 
(define-constant LEXICAL 0)		; the same as compiler.scm
(define-constant PATTERN 2)		; not LEXICAL nor SYNTAX
(define-constant BOUNDARY 3)

(define *root-env* (vector (find-library 'user #f) '() #f #f #f))
(define current-usage-env (make-core-parameter *root-env*))
(define current-macro-env (make-core-parameter *root-env*))
(define current-transformer-env (make-core-parameter '()))
(define (lookup-transformer-env o)
  (cond ((identifier? o)
	 (cond ((assq (id-name o) (current-transformer-env)) =>
		(lambda (r)
		  (and (pair? (cdr r)) (eq? (id-library o) (cadr r)) (cddr r))))
	       (else #f)))
	((symbol? o)
	 (cond ((assq o (current-transformer-env)) =>
		(lambda (r)
		  (and (not (pair? (cdr r)))
		       (cdr r))))
	       (else #f)))))
(define (add-to-transformer-env! o n)
  (let ((cte (current-transformer-env)))
    (if (identifier? o)
	(current-transformer-env (acons (id-name o)
					(cons (id-library o) n)
					cte))
	(current-transformer-env (acons o n cte)))
    n))

(define current-identity (make-core-parameter #f))
(define (generate-identity) (gensym "id."))

;;; identifier
;; we emulate current subr here, so it's rather ugly.
(define (%make-identifier name envs maybe-library pending?)
  (unless (or (symbol? name) (identifier? name))
    (assertion-violation 'make-identifier "symbol or identifier is required"
			 name))
  (let ((n (if (identifier? name) (id-name name) name))
	(lib (if (library? maybe-library)
		 maybe-library
		 (find-library maybe-library #f)))
	(new-env (cond ((null? envs) '())
		       ((identifier? name) (cons envs (id-envs name)))
		       (else (list envs))))
	(identity (cond ((null? envs) #f)
			((identifier? name)
			 (cons (current-identity) (id-identity name)))
			(else (cons (current-identity) #f)))))
    (make-raw-identifier n new-env identity lib pending?)))
(define (make-identifier name envs maybe-library)
  (%make-identifier name envs maybe-library #f))
(define (make-pending-identifier name envs maybe-library)
  (%make-identifier name envs maybe-library #t))

;; This will be inlined since these are not exported.
(define (p1env-library p1env) (vector-ref p1env 0))
(define (p1env-frames p1env) (vector-ref p1env 1))

;; free-identifier=?
;; this needs to be here since it requires both usage and macro env
(define (free-identifier=? id1 id2)
  #|
  (define (compare id1 id2)
    (define uenv (current-usage-env))
    (if (and uenv (eq? (id-name id1) (id-name id2)))
	(let ((v1 (p1env-lookup uenv id1 LEXICAL))
	      (v2 (p1env-lookup uenv id2 LEXICAL)))
	  (if (and (identifier? v1) (identifier? v2))
	      (let ((g1 (find-binding (id-library id1) (id-name id1) #f))
		    (g2 (find-binding (id-library id2) (id-name id2) #f)))
		(eq? g1 g2))
	      (eq? v1 v2)))
	(let ((g1 (find-binding (id-library id1) (id-name id1) #f))
	      (g2 (find-binding (id-library id2) (id-name id2) #f)))
	  (and g1 g2 (eq? g1 g2)))))
  (and (or (identifier? id1)
	   (assertion-violation 'free-identifier=? "identifier required" id1))
       (or (identifier? id2)
	   (assertion-violation 'free-identifier=? "identifier required" id2))
       (compare id1 id2))
  |#
  ;; above works but super slow
  ;; (aprox twice slower than the one implemented in C)
  ;; NB: yet still slower than it used (about twice)
  (vm-free-identifier=? id1 id2 (current-usage-env))
  )

;; implemented in C (see vmlib.stub) and exported from here.
;; (define (bound-identifier=? id1 id2)
;;   (define (compare id1 id2)
;;     (define identity1 (id-identity id1))
;;     (define identity2 (id-identity id2))
;;     (cond ((eq? identity1 identity2))
;; 	  ((or (not identity1) (not identity2)) #f)
;; 	  (else (let loop ((l1 identity1) (l2 identity2))
;; 		  (if (and (pair? l1) (pair? l2))
;; 		      (and (eq? (car l1) (car l2))
;; 			   (loop (cdr l1) (cdr l2)))
;; 		      (eq? l1 l2))))))
;;   (and (or (identifier? id1)
;; 	   (assertion-violation 'bound-identifier=? "identifier required" id1))
;;        (or (identifier? id2)
;; 	   (assertion-violation 'bound-identifier=? "identifier required" id2))
;;        (eq? (id-name id1) (id-name id2))
;;        (compare id1 id2)))

(define .vars (make-identifier '.vars '() '(core macro)))

;; in case of (rename (rnrs) (_ __)) or so...
;; _ and ... are defined in (core) library
(define .bar      (make-identifier '_ '() '(core)))
(define .ellipsis (make-identifier '... '() '(core)))

(define (literal-match? pat lites)
  (define (cmp pred pat lites)
    (let loop ((lites lites))
      (if (null? lites)
	  #f
	  (or (pred pat (car lites))
	      (loop (cdr lites))))))
  (if (identifier? pat)
      ;; literal comparison must be done in sense of
      ;; bound-identifier=?
      (cmp bound-identifier=? pat lites)
      (cmp (lambda (pat lite) (eq? pat (id-name lite))) pat lites)))

(define (bar? expr)
  (or (and (identifier? expr)
	   (free-identifier=? expr .bar))
      (and (variable? expr)
	   (identifier? (p1env-lookup (current-macro-env) expr LEXICAL))
	   (eq? expr '_))))

(define (ellipsis? expr)
  (or (and (identifier? expr)
	   (free-identifier=? expr .ellipsis))
      (and (variable? expr)
	   (identifier? (p1env-lookup (current-macro-env) expr LEXICAL))
	   (eq? expr '...))))

(define (ellipsis-pair? form)
  (and (pair? form)
       (pair? (cdr form))
       (ellipsis? (cadr form))))

(define (ellipsis-splicing-pair? form)
  (and (pair? form)
       (pair? (cdr form))
       (ellipsis? (cadr form))
       (pair? (cddr form))
       (ellipsis? (caddr form))))

(define (ellipsis-quote? form)
  (and (pair? form)
       (ellipsis? (car form))
       (pair? (cdr form))
       (null? (cddr form))))

(define (check-pattern pat lites)

  (define (check-duplicate-variable pat lites)
    (let loop ((lst pat) (pool '()))
      (cond ((pair? lst)
             (loop (cdr lst)
                   (loop (car lst) pool)))
            ((ellipsis? lst) pool)
            ((bar? lst) pool)
            ((variable?  lst)
             (if (literal-match? lst lites)
                 pool
                 (if (memq lst pool)
                     (syntax-violation "syntax pattern"
				       "duplicate pattern variables"
				       (unwrap-syntax pat)
				       (unwrap-syntax lst))
                     (cons lst pool))))
            ((vector? lst)
             (loop (vector->list lst) pool))
            (else pool))))

  (define (check-misplaced-ellipsis pat lites)
    (let loop ((lst pat))
      (cond ((ellipsis? lst)
             (syntax-violation "syntax pattern" "improper use of ellipsis"
			       (unwrap-syntax pat)))
            ((ellipsis-pair? lst)
             (and (variable? (car lst))
                  (literal-match? (car lst) lites)
                  (syntax-violation "syntax pattern"
				    "ellipsis following literal"
				    (unwrap-syntax pat) (unwrap-syntax lst)))
             (let loop2 ((lst (cddr lst)))
               (and (pair? lst)
                    (if (ellipsis? (car lst))
                        (assertion-violation "syntax pattern"
					     "ambiguous use of ellipsis" pat)
                        (loop2 (cdr lst))))))
            ((pair? lst)
             (or (loop (car lst)) (loop (cdr lst))))
            ((vector? lst)
             (loop (vector->list lst)))
            (else #f))))

  (check-misplaced-ellipsis pat lites)
  (check-duplicate-variable pat lites))

;; for global call.
(define .match-syntax-case (make-identifier 'match-syntax-case '()
					    '(core macro)))
(define .list (make-identifier 'list '() '(core macro)))
(define .lambda (make-identifier 'lambda '() '(core macro)))

;; exclude '...
(define (collect-unique-ids expr)
  (let loop ((lst expr) (ans '()))
    (cond ((pair? lst)
           (loop (cdr lst)
                 (loop (car lst) ans)))
          ((ellipsis? lst) ans)
          ((variable? lst)
           (if (memq lst ans) ans (cons lst ans)))
          ((vector? lst)
           (loop (vector->list lst) ans))
          (else ans))))

(define (collect-vars-ranks pat lites depth ranks)
  (cond ((bar? pat) ranks)
        ((variable? pat)
         (if (literal-match? pat lites)
             ranks
             (acons pat depth ranks)))
        ((ellipsis-pair? pat)
         (collect-vars-ranks (cddr pat) lites depth
                             (if (variable? (car pat))
                                 (acons (car pat) (+ depth 1) ranks)
                                 (collect-vars-ranks (car pat) lites
                                                     (+ depth 1) ranks))))
        ((pair? pat)
         (collect-vars-ranks (cdr pat) lites depth
                             (collect-vars-ranks (car pat)
                                                 lites depth ranks)))
        ((vector? pat)
         (collect-vars-ranks (vector->list pat) lites depth ranks))
        (else ranks)))

(define syntax-quote. (make-identifier 'syntax-quote '()
				       '(sagittarius compiler)))

(define (rewrite-form form seen env library
		      make-identifier
		      handle-identifeir)
  (define (seen-or-gen id env library)
    (cond ((hashtable-ref seen id #f))
	  (else (let ((new-id (make-identifier id env library)))
		  (hashtable-set! seen id new-id)
		  new-id))))
  (let loop ((expr form))
    (cond ((pair? expr)
	   (let ((a (loop (car expr)))
		 (d (loop (cdr expr))))
	     (if (and (eq? a (car expr)) (eq? d (cdr expr)))
		 expr
		 (cons a d))))
	  ((vector? expr)
	   (let ((len (vector-length expr)))
	     (let lp ((i 0) (vec #f))
	       (if (= i len)
		   (or vec expr)
		   (let ((e (loop (vector-ref expr i))))
		     (if (eq? e (vector-ref expr i))
			 (lp (+ i 1) vec)
			 (let ((v (or vec (vector-copy expr))))
			   (vector-set! v i e)
			   (lp (+ i 1) v))))))))
	  ((and (identifier? expr)
		(handle-identifeir expr))
	   (seen-or-gen expr env (id-library expr)))
	  ((symbol? expr) (seen-or-gen expr env library))
	  (else expr))))

(define (pattern-identifier? id p1env)
  (number? (p1env-lookup p1env id PATTERN)))

;; syntax-case compiler
(define compile-syntax-case
  (lambda (exp-name expr literals clauses library env mac-env make-p1env)

    (define (extend-env newframe env) (acons PATTERN newframe env))
    
    (define mac-save (current-macro-env))
    (define use-save (current-usage-env))

    (define (rewrite-literals oexpr p1env)
      (define seen (make-eq-hashtable))
      (rewrite-form oexpr seen env library
		    ;; at this stage, symbol must be converted to
		    ;; the same meaning of identifier
		    (lambda (name env library)
		      (make-identifier name (if (symbol? name) '() env)
				       library))
		    ;; if it's identifier then don't
		    (lambda (id) #f)))
    ;; set both macro and usage env so that free-identifier=? can
    ;; use this env for compilation
    (current-macro-env mac-env)
    (current-usage-env mac-env)
    (let ((lites (rewrite-literals literals mac-env)))
      (define (rewrite oexpr patvars p1env)
	(define seen (make-eq-hashtable))
	;; can be for-each but it won't be inlined so this is faster.
	(let loop ((patvars patvars))
	  (unless (null? patvars)
	    (let ((pvar (car patvars)))
	      (hashtable-set! seen (car pvar) (cdr pvar))
	      (loop (cdr patvars)))))
	(for-each (lambda (literal lite)
		    (hashtable-set! seen literal lite)) literals lites)
	(rewrite-form oexpr seen env library
		      ;; at this stage, symbol must be converted to
		      ;; the same meaning of identifier
		      (lambda (name env library)
			(make-identifier name (if (symbol? name) '() env)
					 library))
		      (lambda (id) 
			(and (not (pending-identifier? id))
			     (not (pattern-identifier? id p1env))))))      
      (define (parse-pattern pattern)
	(define (gen-patvar p)
	  (let ((p (car p)))
	    ;; preserve local variable to detect the following:
	    ;; (let-syntax ((_ (syntax-rules ())))
	    ;;   (let-syntax ((foo (syntax-rules () ((_ _) _))))
	    ;;     (foo 'bar)))
	    (cons p (make-identifier p env library))))
	(check-pattern pattern lites)
	(let* ((ranks (collect-vars-ranks pattern lites 0 '()))
	       (pvars (map gen-patvar ranks)))
	  (values (rewrite pattern pvars mac-env)
		  (make-p1env mac-env 
			      (extend-env (rewrite ranks pvars mac-env) env))
		  pvars)))

      (or (and (list? lites) (for-all identifier? lites))
	  (syntax-violation 'syntax-case "invalid literals" expr lites))
      (or (unique-id-list? lites)
	  (syntax-violation 'syntax-case "duplicate literals" expr lites))
      (and (literal-match? .bar lites)
	   (syntax-violation 'syntax-case "_ in literals" expr lites))
      (and (literal-match? .ellipsis lites)
	   (syntax-violation 'syntax-case "... in literals" expr lites))
      
      (let ((r (map (lambda (clause)
		      (smatch clause
			((p expr)
			 (receive (pattern env patvars) (parse-pattern p)
			   (cons `(,.list (,syntax-quote. ,pattern)
					  #f
					  (,.lambda (,.vars)
					    ,(rewrite expr patvars env)))
				 env)))
			((p fender expr)
			 (receive (pattern env patvars) (parse-pattern p)
			   (cons `(,.list (,syntax-quote. ,pattern)
					  (,.lambda (,.vars)
					    ,(rewrite fender patvars env))
					  (,.lambda (,.vars)
					    ,(rewrite expr patvars env)))
				 env)))))
		    clauses)))
	;; restore it
	(current-macro-env mac-save)
	(current-usage-env use-save)
	(values .match-syntax-case
		lites
		(p1env-lookup mac-env .vars LEXICAL BOUNDARY)
		r)))))

(define (count-pair lst)
  (let loop ((lst lst) (n 0))
    (if (pair? lst) (loop (cdr lst) (+ n 1)) n)))

(define (match-ellipsis? expr pat lites)
  (or (null? expr)
      (and (pair? expr)
           (match-pattern? (car expr) (car pat) lites)
           (match-ellipsis? (cdr expr) pat lites))))

(define (match-ellipsis-n? expr pat n lites)
  (or (= n 0)
      (and (pair? expr)
           (match-pattern? (car expr) (car pat) lites)
           (match-ellipsis-n? (cdr expr) pat (- n 1) lites))))

(define (match-pattern? expr pat lites)
  (define (compare pat expr)
    (define (ensure-id id env)
      (if (identifier? id)
	  id
	  (make-identifier id (p1env-frames env) (p1env-library env))))
    ;; pat is pattern variable so it's always identifier
    ;; but in case...
    (let ((p-id (ensure-id pat  (current-macro-env)))
	  (e-id (ensure-id expr (current-usage-env))))
      (free-identifier=? p-id e-id)))
  (cond ((bar? pat) #t)
        ((variable? pat)
         (cond ((literal-match? pat lites)
                (and (variable? expr)
                     (compare pat expr)))
               (else #t)))
        ((ellipsis-pair? pat)
         (if (and (null? (cddr pat)) (list? expr))
             (or (variable? (car pat))
                 (match-ellipsis? expr pat lites))
             (let ((n (- (count-pair expr) (count-pair (cddr pat)))))
               (if (= n 0)
                   (match-pattern? expr (cddr pat) lites)
                   (and (> n 0)
                        (match-ellipsis-n? expr pat n lites)
                        (match-pattern? (list-tail expr n) (cddr pat)
                                        lites))))))
        ((pair? pat)
         (and (pair? expr)
              (match-pattern? (car expr) (car pat) lites)
              (match-pattern? (cdr expr) (cdr pat) lites)))
        ((vector? pat)
         (and (vector? expr)
              (match-pattern? (vector->list expr) (vector->list pat) lites)))
        (else (equal? pat expr))))

(define (union-vars vars evars)
  (if (null? evars)
      vars
      (union-vars (bind-var! (caar evars) (reverse (cdar evars)) vars)
                  (cdr evars))))

(define (bind-var! pat expr vars)
  (cond ((bar? pat) vars)
        (else
         (let ((slot (assq pat vars)))
           (if slot
               (begin (set-cdr! slot (cons expr (cdr slot))) vars)
               (acons pat (list expr) vars))))))

(define (bind-null-ellipsis pat lites vars)
  (let loop ((lst (collect-unique-ids (car pat))) (vars vars))
    (if (null? lst)
        vars
        (loop (cdr lst)
              (if (memq (car lst) lites)
                  vars
                  (bind-var! (car lst) '() vars))))))

(define (bind-ellipsis expr pat lites vars evars)
  (if (null? expr)
      (if (null? evars)
          (bind-null-ellipsis pat lites vars)
          (union-vars vars evars))
      (bind-ellipsis (cdr expr) pat lites vars
                     (bind-pattern (car expr) (car pat) lites evars))))

(define (bind-ellipsis-n expr pat lites n vars evars)
  (if (= n 0)
      (if (null? evars)
          (bind-null-ellipsis pat lites vars)
          (union-vars vars evars))
      (bind-ellipsis-n (cdr expr) pat lites (- n 1) vars
                       (bind-pattern (car expr) (car pat) lites evars))))

(define (bind-pattern expr pat lites vars)
  (cond ((variable? pat)
         (if (literal-match? pat lites)
             vars
             (bind-var! pat expr vars)))
        ((ellipsis-pair? pat)
         (if (and (null? (cddr pat)) (list? expr))
             (if (variable? (car pat))
                 (bind-var! (car pat) expr vars)
                 (bind-ellipsis expr pat lites vars '()))
             (let ((n (- (count-pair expr) (count-pair (cddr pat)))))
               (bind-pattern (list-tail expr n) (cddr pat) lites
                             (if (and (= n 0) (variable? (car pat)))
                                 (bind-var! (car pat) '() vars)
                                 (bind-ellipsis-n expr pat lites n
                                                  vars '()))))))
        ((pair? pat)
         (bind-pattern (cdr expr) (cdr pat) lites
                       (bind-pattern (car expr) (car pat) lites vars)))
        ((vector? pat)
         (bind-pattern (vector->list expr) (vector->list pat) lites vars))
        (else vars)))


(define (match-syntax-case patvars literals form . lst)
  (define (match form pat)
    (and (match-pattern? form pat literals)
	 (bind-pattern form pat literals '())))

  ;; we need to local variable unique so that it won't be global.
  (let loop ((lst lst))
    (if (null? lst)
	(syntax-violation (and (pair? form) (car form)) "invalid syntax"
			  (unwrap-syntax form))
	(let ((clause (car lst)))
	  (let ((pat (car clause))
		(fender (cadr clause))
		(expr (caddr clause)))
	    (let ((vars (match form pat)))
	      (if (and vars
		       (or (not fender)
			   (apply fender (list (append vars patvars)))))
		  (apply expr (list (append vars patvars)))
		  (loop (cdr lst)))))))))

;; compile (syntax ...)
(define .expand-syntax (make-identifier 'expand-syntax '() '(core macro)))
(define (collect-rename-ids template ranks)
  (let ((ids (collect-unique-ids template)))
    (let loop ((lst ids))
      (if (null? lst)
          lst
          (if (assq (car lst) ranks)
              (loop (cdr lst))
              (cons (car lst) (loop (cdr lst))))))))

(define (parse-ellipsis-splicing form)
  (let loop ((len 2) (tail (cdddr form)))
    (cond ((and (pair? tail) (ellipsis? (car tail)))
           (loop (+ len 1) (cdr tail)))
          (else
           (values (list-head form len) tail len)))))

(define (check-template tmpl ranks)
  (define (control-patvar-exists? tmpl depth)
    (let loop ((lst tmpl) (depth depth))
      (cond ((variable? lst)
	     (>= (rank-of lst ranks) depth))
	    ((ellipsis-quote? lst)
	     (any1 (lambda (id) (>= (rank-of id ranks) depth))
		   (collect-unique-ids lst)))
	    ((ellipsis-splicing-pair? lst)
	     (receive (body tail len) (parse-ellipsis-splicing lst)
	       (or (loop body (+ depth 1))
		   (and (loop body 1)
			(loop tail depth)))))
	    ((ellipsis-pair? lst)
	     (or (loop (car lst) (+ depth 1))
		 (and (loop (car lst) 1)
		      (loop (cddr lst) depth))))
	    ((pair? lst)
	     (or (loop (car lst) depth)
		 (loop (cdr lst) depth)))
	    ((vector? lst)
	     (loop (vector->list lst) depth))
	    (else #f))))

  (define (check-escaped lst depth)
    (let loop ((lst lst))
      (cond ((variable? lst)
	     (and (< 0 (rank-of lst ranks) depth)
		  (syntax-violation "syntax template"
				    "too few ellipsis following subtemplate"
				    (unwrap-syntax tmpl)
				    (unwrap-syntax lst))))
	    ((pair? lst)
	     (loop (car lst))
	     (loop (cdr lst)))
	    ((vector? lst)
	     (loop (vector->list lst))))))

  (if (and (= (length tmpl) 2) (ellipsis? (car tmpl)))
      (check-escaped (cadr tmpl) 0)
      (let loop ((lst tmpl) (depth 0))
	(cond ((variable? lst)
	       (and (ellipsis? lst)
		    (syntax-violation "syntax template" "misplaced ellipsis"
				      tmpl))
	       (and (> (rank-of lst ranks) depth)
		    (syntax-violation "syntax template"
				      "too few ellipsis following subtemplate"
				      (unwrap-syntax tmpl)
				      (unwrap-syntax lst))))
	      ((ellipsis-quote? lst)
	       (check-escaped (cadr lst) depth))
	      ((ellipsis-splicing-pair? lst)
	       (receive (body tail len) (parse-ellipsis-splicing lst)
		 (and (= depth 0)
		      (or (control-patvar-exists? (car lst) len)
			  (syntax-violation "syntax template" "missing pattern variable that used in same level as in pattern" (unwrap-syntax tmpl) (unwrap-syntax lst))))
		 (loop body (+ depth 1))
		 (loop tail depth)))
	      ((ellipsis-pair? lst)
	       (cond ((variable? (car lst))
		      (let ((rank (rank-of (car lst) ranks)))
			(cond ((< rank 0)
			       (syntax-violation "syntax template" "misplaced ellipsis following literal" (unwrap-syntax tmpl) (unwrap-syntax (car lst))))
			      ((> rank (+ depth 1))
			       (syntax-violation "syntax template" "too few ellipsis following subtemplate" (unwrap-syntax tmpl) (unwrap-syntax (car lst))))
			      (else
			       (loop (cddr lst) depth)))))
		     ((pair? (car lst))
		      (and (= depth 0)
			   (or (control-patvar-exists? (car lst) (+ depth 1))
			       (syntax-violation "syntax template" "missing pattern variable that used in same level as in pattern" tmpl (car lst))))
		      (loop (car lst) (+ depth 1))
		      (loop (cddr lst) depth))
		     ((null? (car lst))
		      (syntax-violation "syntax template" "misplaced ellipsis following empty list" tmpl))
		     (else
		      (syntax-violation "syntax template" "misplaced ellipsis following literal" tmpl (car lst)))))
	      ((pair? lst)
	       (loop (car lst) depth)
	       (loop (cdr lst) depth))
	      ((vector? lst)
	       (loop (vector->list lst) depth))))))

;; exp-name: current expression name for debug
;; tmpl:     template (if it's in syntax-case, this must be wrapped)
;; env:      p1env only frame
;; mac-env:  whole p1env.
;;
;; template is wrapped by syntax-case so that we can retrieve pattern
;; variables from mac-env.
;; .var is special hidden variable used only in macro expansion phase.
;; it contains all lexical variables for fender and expander. 
;; see compile-syntax-case.
(define (compile-syntax exp-name tmpl env mac-env)
  ;; need to keep which library the symbols are defined.
  (define (rewrite tmpl ranks)
    (rewrite-form tmpl 
		  (make-eq-hashtable) 
		  env
		  (p1env-library mac-env)
		  (lambda (name env library)
		    (make-identifier name (if (symbol? name) '() env)
				     library))
		  (lambda (id)
		    (and (or (not (pending-identifier? id))
			     ;; FIXME 
			     (not (identifier?
				   (p1env-lookup mac-env id LEXICAL))))
			 ;; 'ranks' contains pattern variables so 
			 ;; not need for this
			 ;; (not (pattern-identifier? id mac-env))
			 (not (assoc id ranks bound-identifier=?))))))
  (let* ((ids (collect-unique-ids tmpl))
	 (ranks (filter-map (lambda (id)
			      (let ((p (p1env-lookup mac-env id PATTERN)))
				(and (number? p)
				     (cons id p))))
			    ids))
	 (template (rewrite tmpl ranks)))
    ;; later
    (check-template template ranks)
    (let ((patvar (let ((v (p1env-lookup mac-env .vars LEXICAL BOUNDARY)))
		    ;; if .vars is identifier, then it must be toplevel
		    ;; so not a pattarn variable.
		    (if (identifier? v)
			'()
			.vars))))
      (if (variable? template)
	  (if (null? ranks)
	      `(,.expand-syntax ,patvar
				(,syntax-quote. ,template)
				())
	      `(,.expand-syntax ,patvar
				(,syntax-quote. ,template)
				(,syntax-quote. ,(list (cons template 0)))))
	  `(,.expand-syntax ,patvar 
			    (,syntax-quote. ,template)
			    (,syntax-quote. ,ranks))))))

(define expand-syntax
  (lambda (vars template ranks)
    (define use-env (current-usage-env))
    (define mac-env (current-macro-env))

    (define (contain-identifier? lst)
      (let loop ((lst lst))
	(cond ((pair? lst)
	       (or (null? (car lst)) (loop (car lst)) (loop (cdr lst))))
	      ((vector? lst)
	       (let loop2 ((i (- (vector-length lst) 1)))
		 (and (>= i 0)
		      (or (loop (vector-ref lst i))
			  (loop2 (- i 1))))))
	      (else (identifier? lst)))))

    ;; wrap the given symbol with current usage env frame.
    (define (wrap-symbol sym)
      (define (finish new) (add-to-transformer-env! sym new))
      (let ((use-lib (p1env-library use-env)))
	(finish (make-identifier sym '() use-lib))))

    (define (partial-identifier olst)
      (define (check-binding name env library)
	(and-let* ((id (p1env-lookup env name LEXICAL))
		   ( (identifier? id)) )
	  (find-binding library (id-name id) #f)))
      (define (rename-vector form)
	(define len (vector-length form))
	(let loop ((i 0) (vec #f))
	  (if (= i len)
	      (or vec form)
	      (let ((e (partial-identifier (vector-ref form i))))
		(if (eq? e (vector-ref form i))
		    (loop (+ i 1) vec)
		    (let ((v (or vec (vector-copy form))))
		      (vector-set! v i e)
		      (loop (+ i 1) v)))))))
      (let loop ((lst olst))
	(cond ((contain-identifier? lst)
	       (cond ((pair? lst)
		      (let ((a (loop (car lst))) (d (loop (cdr lst))))
			(if (and (eq? (car lst) a) (eq? (cdr lst) d))
			    lst
			    (cons a d))))
		     ((vector? lst) (rename-vector lst))
		     (else lst)))
	      ((null? lst) '())
	      ((symbol? lst)
	       (cond ((lookup-transformer-env lst))
		     (else (wrap-symbol lst))))
	      ((vector? lst) (rename-vector lst))
	      ((pair? lst)
	       (let ((a (loop (car lst))) (d (loop (cdr lst))))
		 (if (and (eq? a (car lst)) (eq? d (cdr lst)))
		     lst
		     (cons a d))))
	      (else lst))))
    (define (rewrite template)
      (rewrite-form template
		    (make-eq-hashtable)
		    (p1env-frames mac-env)
		    (p1env-library mac-env)
		    (lambda (name env lib)
		      (cond ((lookup-transformer-env name))
			    (else
			     ;; fake the identifier creation
			     ;; TODO not sure if this is actually correct
			     (let* ((env (if (null? env) `((,LEXICAL)) env))
				    (id (make-pending-identifier name env lib)))
			       (add-to-transformer-env! name id)))))
		    ;; preserve pattern variables
		    ;; all template variables must be renamed here
		    (lambda (id)
		      ;; 'ranks' contains pattern variables
		      ;; so not need to call pattern-identifier?
		      (not (assoc id ranks bound-identifier=?)))))
    (if (null? template)
	'()
	(let ((form (transcribe-template (rewrite template) ranks vars)))
	  (cond ((null? form) '())
		;; this causes
		;; (syntax-case '(a b c) () ((a b c) (list #'a #'b #'c)))
		;; results (#<id a> #<id b> #<id c>) but I don't know
		;; how to deal with it...
		((eq? use-env mac-env) form) ; we don't wrap toplevel form
		((identifier? form) form)
		((symbol? form)
		 (cond ((lookup-transformer-env form))
		       (else (wrap-symbol form))))
		(else (partial-identifier form)))))))

(define (rank-of name ranks)
  (define (find-rank ranks)
    (let loop ((ranks ranks))
      (if (null? ranks)
	  -1
	  (let ((slot (car ranks)))
	    (if (bound-identifier=? name (car slot))
		(cdr slot)
		(loop (cdr ranks)))))))
  (find-rank ranks))

(define (subform-of name vars) (cdr (assq name vars)))

(define collect-ellipsis-vars
  (lambda (tmpl ranks depth vars)
    (let ((ids (collect-unique-ids tmpl)))
      ;; vars may contains the same pattern identifier more than once.
      ;; in that case, we need to take only the top most one like usual
      ;; environment lookup (shadowing).
      (let loop ((vars vars) (appeared '()) (r '()))
	(if (null? vars) 
	    (reverse! r)
	    (let* ((slot (car vars))
		   (p    (car slot)))
	      (if (and (member p ids bound-identifier=?)
		       (not (member p appeared bound-identifier=?)))
		  (let ((rank (cdr (assoc p ranks bound-identifier=?))))
		    (loop (cdr vars)
			  (cons p appeared)
			  (cons (cond ((< rank depth) slot)
				      ((null? (cdr slot)) slot)
				      (else (cons (car slot) (cadr slot))))
				r)))
		  (loop (cdr vars) appeared r))))))))

(define contain-rank-moved-var?
  (lambda (tmpl ranks vars)

    (define (traverse-escaped lst depth)
      (let loop ((lst lst) (depth depth))
	(cond ((variable? lst)
	       (< 0 (rank-of lst ranks) depth))
	      ((pair? lst)
	       (or (loop (car lst) depth)
		   (loop (cdr lst) depth)))
	      ((vector? lst)
	       (loop (vector->list lst) depth))
	      (else #f))))

    (let loop ((lst tmpl) (depth 0))
      (cond ((variable? lst)
             (< 0 (rank-of lst ranks) depth))
            ((ellipsis-quote? lst)
             (traverse-escaped (cadr lst) depth))
            ((ellipsis-splicing-pair? lst)
             (let-values (((body tail len) (parse-ellipsis-splicing lst)))
               (or (loop body (+ depth 1))
                   (loop tail depth))))
            ((ellipsis-pair? lst)
             (or (loop (car lst) (+ depth 1))
                 (loop (cddr lst) depth)))
            ((pair? lst)
             (or (loop (car lst) depth)
                 (loop (cdr lst) depth)))
            ((vector? lst)
             (loop (vector->list lst) depth))
            (else #f)))))

(define adapt-to-rank-moved-vars
  (lambda (form ranks vars)
    (define (rewrite-template-ranks-vars tmpl ranks vars)
      (define moved-ranks (make-eq-hashtable))
      (define moved-vars (make-eq-hashtable))

      (define (make-infinite-list e)
	(let ((lst (list e)))
	  (set-cdr! lst lst)
	  lst))

      (define (revealed name depth)
	(cond ((< 0 (rank-of name ranks) depth)
	       (let ((renamed (copy-identifier (gensym) name)))
		 (or (hashtable-ref moved-ranks renamed #f)
		     (let loop ((i (- depth (rank-of name ranks)))
				(var (subform-of name vars)))
		       (cond ((> i 0)
			      (loop (- i 1) 
				    (list (make-infinite-list (car var)))))
			     (else
			      (hashtable-set! moved-ranks renamed depth)
			      (hashtable-set! moved-vars renamed var)))))
		 renamed))
	      ((assq name vars) name)
	      (else name)))

      (define (traverse-escaped lst depth)
	(let loop ((lst lst) (depth depth))
	  (cond ((variable? lst)
		 (revealed lst depth))
		((pair? lst)
		 (cons (loop (car lst) depth)
		       (loop (cdr lst) depth)))
		((vector? lst)
		 (list->vector (loop (vector->list lst) depth)))
		(else lst))))

      (define (rewrite tmpl)
	(let loop ((lst tmpl) (depth 0))
	  (cond ((variable? lst)
		 (revealed lst depth))
		((ellipsis-quote? lst)
		 (cons (car lst)
		       (traverse-escaped (cdr lst) depth)))
		((ellipsis-splicing-pair? lst)
		 (let-values (((body tail len) 
			       (parse-ellipsis-splicing lst)))
		   (append (loop body (+ depth 1))
			   (cons .ellipsis (loop tail depth)))))
		((ellipsis-pair? lst)
		 (cons (loop (car lst) (+ depth 1))
		       (cons .ellipsis (loop (cddr lst) depth))))
		((pair? lst)
		 (cons (loop (car lst) depth)
		       (loop (cdr lst) depth)))
		((vector? lst)
		 (list->vector (loop (vector->list lst) depth)))
		(else lst))))

      (let ((rewrited (rewrite tmpl)))
	(values rewrited
		(append ranks (hashtable->alist moved-ranks))
		(append vars (hashtable->alist moved-vars)))))

    (if (contain-rank-moved-var? form ranks vars)
        (rewrite-template-ranks-vars form ranks vars)
        (values form ranks vars))))

(define (consume-ellipsis-vars ranks depth vars)
  (let ((exhausted #f) (consumed #f))
    ;; consumed exhausted return
    ;; #t       #t    --> #f        error, different size of matched subform
    ;; #t       #f    --> remains   more variable to reveal
    ;; #f       #t    --> #t        all variable revealed
    ;; #f       #f    --> ()        no variable revealed
    (let ((remains
           (let loop ((lst vars))
             (cond ((null? lst) lst)
                   ((< (rank-of (caar lst) ranks) depth)
                    (cons (car lst) (loop (cdr lst))))
                   ((null? (cdar lst))
                    (loop (cdr lst)))
                   ((null? (cddar lst))
                    (set! exhausted #t)
                    (loop (cdr lst)))
                   (else
                    (or (circular-list? (cdar lst)) (set! consumed #t))
                    (acons (caar lst) (cddar lst) (loop (cdr lst))))))))
      (if consumed
          (and (not exhausted) remains)
          (or exhausted '())))))

(define transcribe-template
  (lambda (in-form in-ranks in-vars)
    (let-values (((tmpl ranks vars)
		  (adapt-to-rank-moved-vars in-form in-ranks in-vars)))

      (define (expand-var tmpl vars)
	(cond ((assoc tmpl vars bound-identifier=?)
	       => (lambda (slot)
		    (cond ((null? (cdr slot)) '())
			  (else (cadr slot)))))
	      (else
	       (syntax-violation
		"syntax template"
		"subforms have different size of matched input (variable)"
		`(template: ,(unwrap-syntax in-form) ,tmpl)
		`(subforms: ,@(%map-cons (map car vars)
					 (map (lambda (var)
						(unwrap-syntax (cdr var)))
					      vars)))))))
      (define (expand-ellipsis-var tmpl vars)
	(cond ((assoc tmpl vars bound-identifier=?)
	       => (lambda (slot)
		    (cond ((null? (cdr slot)) '())
			  (else (cadr slot)))))
	      (else
	       (syntax-violation
		"syntax template"
		"subforms have different size of matched input (ellipsis)"
		`(template: ,(unwrap-syntax in-form))
		`(subforms: ,@(unwrap-syntax vars))))))

      (define (expand-ellipsis-template tmpl depth vars)
	(let loop ((expr '())
		   (remains (collect-ellipsis-vars tmpl ranks depth vars)))
	  (cond ((pair? remains)
		 (loop (cons (expand-template tmpl depth remains) expr)
		       (consume-ellipsis-vars ranks depth remains)))
		((null? remains) '())
		((eq? remains #t) (reverse expr))
		(else
		 (syntax-violation
		  "syntax template"
		  "subforms have different size of matched input"
		  `(template: ,(unwrap-syntax in-form))
		  `(subforms: ,@(unwrap-syntax vars)))))))

      (define (expand-escaped-template tmpl depth vars)
	(cond ((variable? tmpl)
	       (if (< (rank-of tmpl ranks) 0)
		   tmpl
		   (expand-var tmpl vars)))
	      ((pair? tmpl)
	       (cons (expand-escaped-template (car tmpl) depth vars)
		     (expand-escaped-template (cdr tmpl) depth vars)))
	      ((vector? tmpl)
	       (list->vector
		(expand-escaped-template (vector->list tmpl) depth vars)))
	      (else tmpl)))

      (define (expand-template tmpl depth vars)
	(cond ((variable? tmpl)
	       (if (< (rank-of tmpl ranks) 0)
		   tmpl
		   (expand-var tmpl vars)))
	      ((ellipsis-quote? tmpl)
	       (expand-escaped-template (cadr tmpl) depth vars))
	      ((ellipsis-splicing-pair? tmpl)
	       (receive (body tail len) (parse-ellipsis-splicing tmpl)
		 (append (apply append
				(expand-ellipsis-template body (+ depth 1) vars))
			 (expand-template tail depth vars))))
	      ((ellipsis-pair? tmpl)
	       (cond
		((variable? (car tmpl))
		 (let ((rank (rank-of (car tmpl) ranks)))
		   (cond ((= rank (+ depth 1))
			  (append (expand-ellipsis-var (car tmpl) vars)
				  (expand-template (cddr tmpl) depth vars))))))
		((pair? (car tmpl))
		 (append (expand-ellipsis-template (car tmpl) (+ depth 1) vars)
			 (expand-template (cddr tmpl) depth vars)))))
	      ((pair? tmpl)
	       (cons (expand-template (car tmpl) depth vars)
		     (expand-template (cdr tmpl) depth vars)))
	      ((vector? tmpl)
	       (list->vector (expand-template (vector->list tmpl) depth vars)))
	      (else tmpl)))

      (if (and (= (length tmpl) 2) (ellipsis? (car tmpl)))
	  (expand-escaped-template (cadr tmpl) 0 vars)
	  (expand-template tmpl 0 vars)))))

;; datum->syntax
(define datum->syntax
  (lambda (template-id datum)
    (define seen (make-eq-hashtable))
    ;; simply converts symbol to identifier.
    (define (rewrite expr)
      (rewrite-form expr
		    (make-eq-hashtable)
		    '() #f ;; dummy
		    (lambda (name env library)
		      (copy-identifier name template-id))
		    (lambda (id) #f)))
    (or (identifier? template-id)
	(assertion-violation 
	 'datum->syntax 
	 (format "expected identifier, but got ~s" template-id)))
    (rewrite datum)))

;; syntax->datum
(define (syntax->datum syntax)
  (unwrap-syntax syntax))

(define (generate-temporaries obj)
  (or (list? obj)
      (assertion-violation 'generate-temporaries
                           (format "expected list, but got ~s" obj)))
  (let ((lib (vm-current-library)))
    (let loop ((i 0) (obj obj) (r '()))
      (if (null? obj)
	  r
	  (loop (+ i 1)
		(cdr obj)
		;; hope it's unique enough
		(cons (make-identifier 
		       (string->symbol 
			(format "~a.~a'~a"
				(gensym "temp.")
				;; make it smaller
				(number->string (microsecond) 32)
				i))
		       '() lib)
		      r))))))

(define *variable-transformer-mark* (list 'variable-transformer))
(define (variable-transformer? o)
  (and (macro? o) (macro? (macro-data o))))
;; see blow
;; (define (variable-transformer? o)
;;   (and (macro? o)
;;        (eq? (macro-data o) *variable-transformer-mark*)))

;; make-macro-transformer
;; TODO use this when I'm done with cache refactoring.
;; NB: this version makes cache break. the (thunk) must not be
;;     called sint it may contain lifted lambda.
;; (define (make-macro-transformer name thunk env cb)
;;   (define transformer (thunk))
;;   (define (macro-transform me expr p1env data)
;;     (let ((usave (current-usage-env))
;; 	  (msave (current-macro-env))
;; 	  (isave (current-identity)))
;;       (current-usage-env p1env)
;;       (current-macro-env (macro-env me))
;;       (current-identity (generate-identity))
;;       (current-transformer-env '()) ;; we don't need the value.
;;       (dynamic-wind values
;; 	  (lambda () ((macro-data me) expr))
;; 	  (lambda ()
;; 	    (current-transformer-env '())
;; 	    (current-usage-env usave)
;; 	    (current-macro-env msave)
;; 	    (current-identity  isave)))))
;;   (if (macro? transformer)
;;       (make-macro name (macro-transformer transformer)
;; 		  *variable-transformer-mark* (macro-env transformer)
;; 		  cb)
;;       (make-macro name macro-transform transformer env cb)))

(define (macro-transform me expr p1env data)
  (let ((transformer data)
	(usave (current-usage-env))
	(msave (current-macro-env))
	(isave (current-identity)))
    (current-usage-env p1env)
    (current-macro-env (macro-env me))
    (current-identity (generate-identity))
    (current-transformer-env '()) ;; we don't need the value.
    (dynamic-wind values
	(lambda ()
	  (if (macro? transformer)
	      ((macro-transformer transformer) transformer
	       expr (macro-env me) (macro-data transformer))
	      (transformer expr)))
	(lambda ()
	  (current-transformer-env '())
	  (current-usage-env usave)
	  (current-macro-env msave)
	  (current-identity  isave)))))
(define (make-macro-transformer name thunk env cb)
  (make-macro name macro-transform (thunk) env cb))

(define (make-variable-transformer proc)
  (make-macro *variable-transformer-mark*
	      (lambda (m expr p1env data)
		(define (rewrite expr env)
		  (rewrite-form expr (make-eq-hashtable) (p1env-frames env)
				(p1env-library env) 
				;; the same as syntax-case
				(lambda (name env library)
				  (make-identifier name
						   (if (symbol? name) '() env)
						   library))
				(lambda (id) 
				  (and (not (pending-identifier? id))
				       (not (pattern-identifier? id p1env))))))
		;; use current usage env, issue 93
		(proc (rewrite expr (current-usage-env))))
	      '()
	      (current-macro-env)))

;; 'rename' procedure - we just return a resolved identifier
;; NB: when dict is #f, means caller wants to only rename but not store.
(define (er-rename symid p1env dict)
  (define (rename symid dict env lib)
    (let ((id (make-identifier symid env lib)))
      (when dict (hashtable-set! dict symid id))
      id))
  (unless (variable? symid)
    (assertion-violation 'er-macro-transformer
     (wrong-type-argument-message "a symbol or an identifier" symid 0)))
  (if (symbol? symid)
      (or (and dict (hashtable-ref dict symid #f))
	  (rename symid dict (p1env-frames p1env) (p1env-library p1env)))
      ;; the same renaming rule as syntax-case
      ;; TODO should we only rename when the `symid` is a pending identifier
      ;;      and locally bound the same as compile-syntax?
      ;;      the above is actually depending on non existing er-macro-expander
      ;;      specification. we can decide when the spec is there.
      (or (and (not (pending-identifier? symid))
	       (or (and dict (hashtable-ref dict symid #f))
		   (rename symid dict (p1env-frames p1env)
			   (id-library symid))))
	  symid)))

;; er-macro-transformer
(define (er-macro-transformer f)
  (lambda (expr)
    (let ((dict (make-eq-hashtable)))
      ;; renames given form not only symbol/identifier
      (define (rename s) 
	(define macro-env (current-macro-env))
	(define (rec form)
	  (cond ((pair? form)
		 (let ((a (rec (car form)))
		       (d (rec (cdr form))))
		   (if (and (eq? a (car form)) (eq? d (cdr form)))
		       form
		       (cons a d))))
		((vector? form)
		 (let ((len (vector-length form)))
		   (let loop ((i 0) (vec #f))
		     (if (= i len)
			 (or vec form)
			 (let ((e (rec (vector-ref form i))))
			   (if (eq? e (vector-ref form i))
			       (loop (+ i 1) vec)
			       (let ((v (or vec (vector-copy form))))
				 (vector-set! v i e)
				 (loop (+ i 1) v))))))))
		((variable? form) (er-rename form macro-env dict))
		(else form)))
	(rec s))
      (define (compare a b)
	(define (ensure-id id env)
	  (if (identifier? id)
	      id
	      (er-rename id env #f)))
	(cond ((and (pair? a) (pair? b))
	       (and (compare (car a) (car b))
		    (compare (cdr a) (cdr b))))
	      ((and (variable? a) (variable? b))
	       (let ((env (current-usage-env)))
		 (free-identifier=? (ensure-id a env) (ensure-id b env))))
	      ((and (vector? a) (vector? b))
	       (let ((al (vector-length a))
		     (bl (vector-length b)))
		 (and (= al bl)
		      (let loop ((i 0))
			(or (= i al)
			    (and (compare (vector-ref a i) (vector-ref b i))
				 (loop (+ i 1))))))))
	      (else (equal? a b))))
      (f expr rename compare))))

	 
